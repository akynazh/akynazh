<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>assembly on Norwegian Wood</title>
    <link>/tags/assembly/</link>
    <description>Recent content in assembly on Norwegian Wood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Jzh</copyright>
    <lastBuildDate>Thu, 09 Jun 2022 23:37:51 +0800</lastBuildDate><atom:link href="/tags/assembly/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用x86_64汇编写一个自旋锁</title>
      <link>/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/</link>
      <pubDate>Thu, 09 Jun 2022 23:37:51 +0800</pubDate>
      
      <guid>/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/</guid>
      <description>一、理论分析 自旋锁，顾名思义，即自己不断旋转重复进行的锁，当多个线程访问同一资源时，为实现互斥访问，必须给目标资源加锁，此时只允许一个线程访问，此时其他线程无法访问，并且一直重复请求访问，直到该锁被释放。访问完资源的线程及时释放锁以供其他资源访问。
自旋锁可以通过比较替换算法实现：设锁为1时被占用，为0时空闲。当一个线程请求锁时，即进入请求锁循环“spinlock”，设预期值为0，修改值为1，让锁值与预期值比较，若锁值等于预期值，则锁空闲，将锁值置为修改值，退出spinlock循环；若锁值不等于预期值，则证明锁被占用，继续spinlock循环。
为验证是否成功实现自旋，开启一个释放锁线程，请求锁线程自旋一段时间后，释放锁线程进行锁的释放，即把锁值置为预期值0。此时，请求锁线程成功获得锁并退出spinlock循环。
二、设计与实现 使用x86_64汇编实现自旋锁：
Intel语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // 尝试获取锁 void lock(long *p) { long a = 0, c = 1; printf(&amp;#34;try to get lock...\n&amp;#34;); __asm__( &amp;#34;push rax \n\t&amp;#34; &amp;#34;push rcx \n\t&amp;#34; &amp;#34;spin_lock: \n\t&amp;#34; &amp;#34;mov rcx, %[c] \n\t&amp;#34; &amp;#34;mov rax, %[a] \n\t&amp;#34; // 比较并替换算法，若p==rax==0则获得锁并使p=rcx(==1)，若p(==1)!</description>
    </item>
    
  </channel>
</rss>
