<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>springcloud on Norwegian Wood</title>
    <link>/tags/springcloud/</link>
    <description>Recent content in springcloud on Norwegian Wood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Jzh</copyright>
    <lastBuildDate>Fri, 29 Jul 2022 18:26:44 +0800</lastBuildDate><atom:link href="/tags/springcloud/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Zipkin使用记录</title>
      <link>/posts/2022/07/zipkin-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 18:26:44 +0800</pubDate>
      
      <guid>/posts/2022/07/zipkin-usage-record/</guid>
      <description>Zipkin的作用  查看微服务调用过程； 分析微服务依赖关系； 方便地找到调用过程错误发生位置。  Zipkin使用记录 一、下载Zipkin并运行：
1  java -jar zipkin.jar   这样成功运行后，默认在端口9411可以查看图形管理界面。
二、依赖引入
在所有调用到的微服务中引入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   三、配置文件
1 2 3 4 5 6  spring: zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 # 采样率介于0和1之间，1表示全部采集   测试 通过service-name标签搜索自己的微服务名称，即可检索到与该微服务有依赖的所有微服务，可查看调用过程，依赖关系等。
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>SpringCloud-Stream使用记录</title>
      <link>/posts/2022/07/springcloud-stream-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 17:26:05 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-stream-usage-record/</guid>
      <description>为何使用Stream？ 实现消息的收发可以用许多种方式来实现，如Kafka，RabbitMQ等，而通过Stream可以方便地通过一个Binder对象与这些不同的实现工具对接，应用程序通过Inputs和Outputs来与Binder交互即可实现消息的收发，这样我们就只需要知道如何与Stream交互即可方便地使用消息驱动。
下图即Stream工作原理：
Stream使用记录 一、依赖导入 除去一些基本依赖之外，发布端和订阅端均导入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-stream-rabbit&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、基本配置 发布端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: output: destination: myExchange content-type: application/json binder: defaultRabbit   订阅端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: input: destination: myExchange content-type: application/json binder: defaultRabbit group: jzh1   注意，两个订阅端如果实现同一微服务，group应该一样，这样，在同一个组内会发生竞争关系，只有其中一个可以消费（默认采用轮询的机制处理），避免了出现重复消费的问题。</description>
    </item>
    
    <item>
      <title>Config结合Bus使用记录</title>
      <link>/posts/2022/07/config-combined-with-bus-usage-record/</link>
      <pubDate>Wed, 27 Jul 2022 22:00:55 +0800</pubDate>
      
      <guid>/posts/2022/07/config-combined-with-bus-usage-record/</guid>
      <description>为何要使用Config和Bus Config可以进行多个微服务下的全局配置，更加方便，易于管理。
当全局配置修改时，需要通知各个微服务，一个一个地通知是非常耗时的，如果可以通过广播的方式快速将消息传递出去就轻松多了，而通过Bus即可实现这一点。
测试方法 一、在6996端口通过git拉取全局配置，相当于一个ConfigServer，6886和6776端口作为ConfigClient；
二、Bus结合RabbitMQ实现，修改配置时，只通知ConfigServer，达到消息广播的效果。
依赖引入 一、ConfigServer端：
1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、ConfigClient端：
1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   其他一些基本包就省略了。
文件配置 一、ConfigServer端：
以下为application.yml:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  spring: cloud: config: server: git: # github项目地址 uri: https://github.</description>
    </item>
    
    <item>
      <title>SpringCloud-Gateway使用记录</title>
      <link>/posts/2022/07/springcloud-gateway-usage-record/</link>
      <pubDate>Tue, 26 Jul 2022 18:33:44 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-gateway-usage-record/</guid>
      <description>网关的作用 如图所示，网关介于外部请求和具体微服务之间，在不暴露内部微服务端口的情况下，通过一个或者多个指定的网关端口统一地处理外部各种请求。
使用SpringCloud Gateway 依赖引入 除了基本依赖以外，引入下列依赖：
1 2 3 4 5 6 7 8 9  &amp;lt;!-- others --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   注意不能引入web相关依赖，因为Gateway是基于WebFlux的。
文件配置 列出部分重要配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14  server: port: 9669 cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: path_route uri: lb://CLOUD-PAYMENT-SERVICE # lb：负载均衡 predicates: - Path=/payment/** - After=2022-07-26T17:33:52.</description>
    </item>
    
    <item>
      <title>Hystrix实现服务熔断与监控</title>
      <link>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</link>
      <pubDate>Tue, 26 Jul 2022 11:39:11 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</guid>
      <description>什么是服务熔断 概念 应对微服务雪崩效应的一种链路保护机制，类似保险丝。
关于雪崩效应 微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务C，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应。
实现机制 当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。
通过Hystrix实现服务熔断，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，就会启动熔断机制，断路器打开。而在一段时间之后，断路器会变为半开状态，此时允许部分微服务调用，如果都成功了，即不超过设定好的阈值，那么断路器将恢复为关闭状态。
如下图所示：（来自Martin Fowler大神的博客）
应用场景 微服务架构中，多个微服务相互调用出使用
Hystrix实现服务熔断 环境搭建 1. 关于pom.xml 1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   2. 启动类添加@EnableHystrix注解，表示使用熔断器。 实现服务熔断 1. PaymentService.java 1 2 3 4  public interface PaymentService { ... String circuitBreaker(Integer id); }   2. PaymentServiceImpl.java 设置服务熔断的核心配置：
（1）启用断路器:
1  @HystrixProperty(name = &amp;#34;circuitBreaker.enabled&amp;#34;, value = &amp;#34;true&amp;#34;)   （2）设置请求次数:</description>
    </item>
    
    <item>
      <title>Hystrix实现服务降级</title>
      <link>/posts/2022/07/hytrix-enables-service-degradation/</link>
      <pubDate>Tue, 26 Jul 2022 10:59:08 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-enables-service-degradation/</guid>
      <description>什么是服务降级 概念 一般指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而释放服务器资源的资源以保证核心业务的正常高效运行。
应用场景 多用于微服务架构中，一般当整个微服务架构整体的负载超出了预设的上限阈值（和服务器的配置性能有关系），或者即将到来的流量预计会超过预设的阈值时。
大致实现过程 为了预防某些功能出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。
使用Hystrix实现服务降级 本实验配合了Feign实现，利用Feign通过接口的方式解耦服务这一特点，通过在实现服务接口的类来编写方法对应的fallback方法。
环境搭建 一、关于pom
在消费方实现服务降级，除了基本包导入外，导入以下：
1 2 3 4 5 6 7 8 9 10 11 12  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、关于application.yml
除了基本配置外，以下两个超时时间的配置需要格外注意：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 设置feign超时时间（默认为1秒） feign: hystrix: enabled: true client: config: default: ConnectTimeOut: 5000 ReadTimeOut: 5000 # 设置hystrix超时时间（默认为1秒） hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000   其他关于Feign的环境配置省略了。</description>
    </item>
    
    <item>
      <title>OpenFeign使用记录</title>
      <link>/posts/2022/07/openfeign-usage-record/</link>
      <pubDate>Fri, 22 Jul 2022 17:39:24 +0800</pubDate>
      
      <guid>/posts/2022/07/openfeign-usage-record/</guid>
      <description>为什么要使用OpenFeign 之前在消费端使用RestTemplate时，每次请求都要进行诸如
1  restTemplate.postForObject(PAYMENT_URL + &amp;#34;/payment/create&amp;#34;, payment, CommonResult.class);   这样的调用，需要指定较多参数，当一个接口调用中需要非常多这样的请求时，会比较繁琐，而且这种方式不够抽象。
OpenFegin利用面向接口编程的思想，抽象化，简化了上述操作。
使用OpenFeign 关于pom.xml 1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   关于application.yml 除了基本配置内容外，注意以下配置：
1 2 3 4 5 6 7 8 9 10 11  feign: # 设置feign客户端超时时间（默认为1秒） client: config: default: ConnectTimeOut: 10000 ReadTimeOut: 10000 # 针对每个接口设置日志监控级别 logging: level: com.jzh.springcloud.service.PaymentService: debug # feign日志以什么级别监控端口   编写服务接口 首先在启动类开启@EnableFeignClients注解，接着编写服务接口：
 添加@FeignClient注解，值为对应微服务名； 方法对应微服务Controller下的方法即可。  1 2 3 4 5 6 7 8 9  @Component @FeignClient(value = &amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;) public interface PaymentService { @GetMapping(&amp;#34;/payment/get/{id}&amp;#34;) CommonResult&amp;lt;Payment&amp;gt; getPaymentById(@PathVariable(&amp;#34;id&amp;#34;) Long id); @PostMapping(&amp;#34;/payment/create&amp;#34;) CommonResult&amp;lt;Integer&amp;gt; createPayment(@RequestBody Payment payment); }   调用接口 注入PaymentController接口，然后即可调用它的方法。</description>
    </item>
    
    <item>
      <title>理解Ribbon并自己实现负载均衡</title>
      <link>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</link>
      <pubDate>Wed, 20 Jul 2022 17:07:35 +0800</pubDate>
      
      <guid>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</guid>
      <description>负载均衡（LB）是什么 对于用户的某个请求，将有多个相同功能的服务点服务该请求，某个服务点挂了，其他服务点还是可以进行服务，这样就实现了系统的高可用。
关于集中式LB和进程内LB 集中式LB 在服务的消费方和提供方之间使用独立的LB设施，（软硬件均可，软件如Nginx，硬件如F5），由该设施负责把访问请求通过某种策略（可自行指定）转发至服务的提供方。
进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务点进行服务。
Ribbon属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它获取服务提供方的地址。
使用Ribbon实现负载均衡 关于导包 1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 已经包含了ribbon --&amp;gt; &amp;lt;/dependency&amp;gt;   注意eureka内置了ribbon。
开启注解 1 2 3 4 5 6 7 8  @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 赋予负载均衡能力  public RestTemplate getRestTemplate() { return new RestTemplate(); } }   访问相同服务名地址即可。
修改Ribbon负载均衡规则 所有规则均实现了IRule接口，通过查看接口实现类即可知道规则的种类。
默认是RoundRobinRule（轮询）这一规则。
下面修改为RandomRule（随机）这一规则：
在启动类扫描不到的包下创建规则： 1 2 3 4 5 6 7  @Configuration public class MyRibbonRule { @Bean public IRule myRule() { return new RandomRule(); } }   在启动类指定规则： 1 2 3 4 5 6 7 8  @SpringBootApplication @EnableEurekaClient @RibbonClient(name=&amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;, configuration = MyRibbonRule.</description>
    </item>
    
    <item>
      <title>Consul配置过程及测试</title>
      <link>/posts/2022/07/consul-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 16:34:39 +0800</pubDate>
      
      <guid>/posts/2022/07/consul-configuration-process-and-test/</guid>
      <description>前言 类似于zookeeper和eureka，也起到微服务注册中心的作用, 满足分布式系统中的CP原则，是弱可用性的。
不同于zookeeper和eureka这两种主要由Java编写的语言，它主要由Go语言编写。
配置Consul环境  下载consul，配置环境变量。 运行consul agent -dev开启服务。 默认端口为8500，访问localhost:8500进入管理界面。  编写springcloud服务代码 一、关于pom.xml
除了一些基本包的导入之外，关于consul包的导入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、关于application.yml
1 2 3 4 5 6 7 8 9 10  spring: application: name: cloud-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name}   三、启动类添加@EnableDiscoveryClient注解。
consul测试 较为简单，访问localhost:8500查看即可。
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>Zookeeper配置过程与测试</title>
      <link>/posts/2022/07/zookeeper-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 12:00:37 +0800</pubDate>
      
      <guid>/posts/2022/07/zookeeper-configuration-process-and-test/</guid>
      <description>前言 Zookeeper类似于Eureka，起到微服务注册中心的作用，满足分布式系统中的CP原则，是弱可用性的。
配置zookeeper环境 安装zookeeper 下载并解压zookeeper包为zookeeper3.7.1（假设下载的是3.7.1版本）。
然后将zookeeper解压缩到/usr/local/zookeeper3.7.1。
配置参数 一、编辑/conf/zoo.cfg
编辑zookeeper包内配置文件/conf/zoo.cfg（先创建，再将zoo_sample.cfg内容复制到其中）
修改或添加以下内容：
1 2  dataDir=/usr/local/zookeeper3.7.1/dataDir dataLogDir=/usr/local/zookeeper3.7.1/dataLogDir   注意同时创建对应文件夹。其中端口号默认为2181，也可以进行修改。
二、 配置环境变量
1 2 3  # zookeeper export ZOOKEEPER_HOME=/usr/local/zookeeper3.7.1 export PATH=$PATH:$ZOOKEEPER_HOME/bin   接着通过source命令生效。
开启zookeeper连接 （前置条件是已配好java环境）
执行zkServer.sh start即可。
查看连接情况： 1 2 3 4 5 6  zkServer.sh status ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper3.7.1/bin/../conf/zoo.cfg Client port found: 2181. Client address: localhost. Client SSL: false. Mode: standalone   可见已经开启成功了。</description>
    </item>
    
    <item>
      <title>Eureka配置过程与理解</title>
      <link>/posts/2022/07/eureka-configuration-process-and-understanding/</link>
      <pubDate>Sun, 17 Jul 2022 11:39:35 +0800</pubDate>
      
      <guid>/posts/2022/07/eureka-configuration-process-and-understanding/</guid>
      <description>前言 起到微服务注册中心的作用，满足分布式系统中的AP原则，是弱一致性的。
Eureka微服务架构图  服务接口采用集群模式，8001和8002端口都实现支付接口服务。 用户接口在运行在80端口，调用8001和8002的服务。 注册中心内部也采用集群模式，7001和7002端口都实现注册服务。  引入Eureka依赖说明 client端：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   server端：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   7001和7002端口关键配置内容 一、启动类开启注解
1 2 3 4 5 6 7  @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class, args); } }   二、application.yml文件配置
对于7001端口服务：（7002端口类似）
1 2 3 4 5 6 7 8 9 10 11  eureka: instance: hostname: eureka7001.</description>
    </item>
    
  </channel>
</rss>
