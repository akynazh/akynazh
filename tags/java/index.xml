<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Norwegian Wood</title>
    <link>/tags/java/</link>
    <description>Recent content in java on Norwegian Wood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Jzh</copyright>
    <lastBuildDate>Fri, 29 Jul 2022 18:26:44 +0800</lastBuildDate><atom:link href="/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Zipkin使用记录</title>
      <link>/posts/2022/07/zipkin-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 18:26:44 +0800</pubDate>
      
      <guid>/posts/2022/07/zipkin-usage-record/</guid>
      <description>Zipkin的作用  查看微服务调用过程； 分析微服务依赖关系； 方便地找到调用过程错误发生位置。  Zipkin使用记录 一、下载Zipkin并运行：
1  java -jar zipkin.jar   这样成功运行后，默认在端口9411可以查看图形管理界面。
二、依赖引入
在所有调用到的微服务中引入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   三、配置文件
1 2 3 4 5 6  spring: zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 # 采样率介于0和1之间，1表示全部采集   测试 通过service-name标签搜索自己的微服务名称，即可检索到与该微服务有依赖的所有微服务，可查看调用过程，依赖关系等。
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>SpringCloud-Stream使用记录</title>
      <link>/posts/2022/07/springcloud-stream-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 17:26:05 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-stream-usage-record/</guid>
      <description>为何使用Stream？ 实现消息的收发可以用许多种方式来实现，如Kafka，RabbitMQ等，而通过Stream可以方便地通过一个Binder对象与这些不同的实现工具对接，应用程序通过Inputs和Outputs来与Binder交互即可实现消息的收发，这样我们就只需要知道如何与Stream交互即可方便地使用消息驱动。
下图即Stream工作原理：
Stream使用记录 一、依赖导入 除去一些基本依赖之外，发布端和订阅端均导入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-stream-rabbit&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、基本配置 发布端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: output: destination: myExchange content-type: application/json binder: defaultRabbit   订阅端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: input: destination: myExchange content-type: application/json binder: defaultRabbit group: jzh1   注意，两个订阅端如果实现同一微服务，group应该一样，这样，在同一个组内会发生竞争关系，只有其中一个可以消费（默认采用轮询的机制处理），避免了出现重复消费的问题。</description>
    </item>
    
    <item>
      <title>Config结合Bus使用记录</title>
      <link>/posts/2022/07/config-combined-with-bus-usage-record/</link>
      <pubDate>Wed, 27 Jul 2022 22:00:55 +0800</pubDate>
      
      <guid>/posts/2022/07/config-combined-with-bus-usage-record/</guid>
      <description>为何要使用Config和Bus Config可以进行多个微服务下的全局配置，更加方便，易于管理。
当全局配置修改时，需要通知各个微服务，一个一个地通知是非常耗时的，如果可以通过广播的方式快速将消息传递出去就轻松多了，而通过Bus即可实现这一点。
测试方法 一、在6996端口通过git拉取全局配置，相当于一个ConfigServer，6886和6776端口作为ConfigClient；
二、Bus结合RabbitMQ实现，修改配置时，只通知ConfigServer，达到消息广播的效果。
依赖引入 一、ConfigServer端：
1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、ConfigClient端：
1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   其他一些基本包就省略了。
文件配置 一、ConfigServer端：
以下为application.yml:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  spring: cloud: config: server: git: # github项目地址 uri: https://github.</description>
    </item>
    
    <item>
      <title>SpringCloud-Gateway使用记录</title>
      <link>/posts/2022/07/springcloud-gateway-usage-record/</link>
      <pubDate>Tue, 26 Jul 2022 18:33:44 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-gateway-usage-record/</guid>
      <description>网关的作用 如图所示，网关介于外部请求和具体微服务之间，在不暴露内部微服务端口的情况下，通过一个或者多个指定的网关端口统一地处理外部各种请求。
使用SpringCloud Gateway 依赖引入 除了基本依赖以外，引入下列依赖：
1 2 3 4 5 6 7 8 9  &amp;lt;!-- others --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   注意不能引入web相关依赖，因为Gateway是基于WebFlux的。
文件配置 列出部分重要配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14  server: port: 9669 cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: path_route uri: lb://CLOUD-PAYMENT-SERVICE # lb：负载均衡 predicates: - Path=/payment/** - After=2022-07-26T17:33:52.</description>
    </item>
    
    <item>
      <title>Hystrix实现服务熔断与监控</title>
      <link>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</link>
      <pubDate>Tue, 26 Jul 2022 11:39:11 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</guid>
      <description>什么是服务熔断 概念 应对微服务雪崩效应的一种链路保护机制，类似保险丝。
关于雪崩效应 微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务C，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应。
实现机制 当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。
通过Hystrix实现服务熔断，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，就会启动熔断机制，断路器打开。而在一段时间之后，断路器会变为半开状态，此时允许部分微服务调用，如果都成功了，即不超过设定好的阈值，那么断路器将恢复为关闭状态。
如下图所示：（来自Martin Fowler大神的博客）
应用场景 微服务架构中，多个微服务相互调用出使用
Hystrix实现服务熔断 环境搭建 1. 关于pom.xml 1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   2. 启动类添加@EnableHystrix注解，表示使用熔断器。 实现服务熔断 1. PaymentService.java 1 2 3 4  public interface PaymentService { ... String circuitBreaker(Integer id); }   2. PaymentServiceImpl.java 设置服务熔断的核心配置：
（1）启用断路器:
1  @HystrixProperty(name = &amp;#34;circuitBreaker.enabled&amp;#34;, value = &amp;#34;true&amp;#34;)   （2）设置请求次数:</description>
    </item>
    
    <item>
      <title>Hystrix实现服务降级</title>
      <link>/posts/2022/07/hytrix-enables-service-degradation/</link>
      <pubDate>Tue, 26 Jul 2022 10:59:08 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-enables-service-degradation/</guid>
      <description>什么是服务降级 概念 一般指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而释放服务器资源的资源以保证核心业务的正常高效运行。
应用场景 多用于微服务架构中，一般当整个微服务架构整体的负载超出了预设的上限阈值（和服务器的配置性能有关系），或者即将到来的流量预计会超过预设的阈值时。
大致实现过程 为了预防某些功能出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。
使用Hystrix实现服务降级 本实验配合了Feign实现，利用Feign通过接口的方式解耦服务这一特点，通过在实现服务接口的类来编写方法对应的fallback方法。
环境搭建 一、关于pom
在消费方实现服务降级，除了基本包导入外，导入以下：
1 2 3 4 5 6 7 8 9 10 11 12  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、关于application.yml
除了基本配置外，以下两个超时时间的配置需要格外注意：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 设置feign超时时间（默认为1秒） feign: hystrix: enabled: true client: config: default: ConnectTimeOut: 5000 ReadTimeOut: 5000 # 设置hystrix超时时间（默认为1秒） hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000   其他关于Feign的环境配置省略了。</description>
    </item>
    
    <item>
      <title>OpenFeign使用记录</title>
      <link>/posts/2022/07/openfeign-usage-record/</link>
      <pubDate>Fri, 22 Jul 2022 17:39:24 +0800</pubDate>
      
      <guid>/posts/2022/07/openfeign-usage-record/</guid>
      <description>为什么要使用OpenFeign 之前在消费端使用RestTemplate时，每次请求都要进行诸如
1  restTemplate.postForObject(PAYMENT_URL + &amp;#34;/payment/create&amp;#34;, payment, CommonResult.class);   这样的调用，需要指定较多参数，当一个接口调用中需要非常多这样的请求时，会比较繁琐，而且这种方式不够抽象。
OpenFegin利用面向接口编程的思想，抽象化，简化了上述操作。
使用OpenFeign 关于pom.xml 1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   关于application.yml 除了基本配置内容外，注意以下配置：
1 2 3 4 5 6 7 8 9 10 11  feign: # 设置feign客户端超时时间（默认为1秒） client: config: default: ConnectTimeOut: 10000 ReadTimeOut: 10000 # 针对每个接口设置日志监控级别 logging: level: com.jzh.springcloud.service.PaymentService: debug # feign日志以什么级别监控端口   编写服务接口 首先在启动类开启@EnableFeignClients注解，接着编写服务接口：
 添加@FeignClient注解，值为对应微服务名； 方法对应微服务Controller下的方法即可。  1 2 3 4 5 6 7 8 9  @Component @FeignClient(value = &amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;) public interface PaymentService { @GetMapping(&amp;#34;/payment/get/{id}&amp;#34;) CommonResult&amp;lt;Payment&amp;gt; getPaymentById(@PathVariable(&amp;#34;id&amp;#34;) Long id); @PostMapping(&amp;#34;/payment/create&amp;#34;) CommonResult&amp;lt;Integer&amp;gt; createPayment(@RequestBody Payment payment); }   调用接口 注入PaymentController接口，然后即可调用它的方法。</description>
    </item>
    
    <item>
      <title>理解Ribbon并自己实现负载均衡</title>
      <link>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</link>
      <pubDate>Wed, 20 Jul 2022 17:07:35 +0800</pubDate>
      
      <guid>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</guid>
      <description>负载均衡（LB）是什么 对于用户的某个请求，将有多个相同功能的服务点服务该请求，某个服务点挂了，其他服务点还是可以进行服务，这样就实现了系统的高可用。
关于集中式LB和进程内LB 集中式LB 在服务的消费方和提供方之间使用独立的LB设施，（软硬件均可，软件如Nginx，硬件如F5），由该设施负责把访问请求通过某种策略（可自行指定）转发至服务的提供方。
进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务点进行服务。
Ribbon属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它获取服务提供方的地址。
使用Ribbon实现负载均衡 关于导包 1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 已经包含了ribbon --&amp;gt; &amp;lt;/dependency&amp;gt;   注意eureka内置了ribbon。
开启注解 1 2 3 4 5 6 7 8  @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 赋予负载均衡能力  public RestTemplate getRestTemplate() { return new RestTemplate(); } }   访问相同服务名地址即可。
修改Ribbon负载均衡规则 所有规则均实现了IRule接口，通过查看接口实现类即可知道规则的种类。
默认是RoundRobinRule（轮询）这一规则。
下面修改为RandomRule（随机）这一规则：
在启动类扫描不到的包下创建规则： 1 2 3 4 5 6 7  @Configuration public class MyRibbonRule { @Bean public IRule myRule() { return new RandomRule(); } }   在启动类指定规则： 1 2 3 4 5 6 7 8  @SpringBootApplication @EnableEurekaClient @RibbonClient(name=&amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;, configuration = MyRibbonRule.</description>
    </item>
    
    <item>
      <title>Consul配置过程及测试</title>
      <link>/posts/2022/07/consul-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 16:34:39 +0800</pubDate>
      
      <guid>/posts/2022/07/consul-configuration-process-and-test/</guid>
      <description>前言 类似于zookeeper和eureka，也起到微服务注册中心的作用, 满足分布式系统中的CP原则，是弱可用性的。
不同于zookeeper和eureka这两种主要由Java编写的语言，它主要由Go语言编写。
配置Consul环境  下载consul，配置环境变量。 运行consul agent -dev开启服务。 默认端口为8500，访问localhost:8500进入管理界面。  编写springcloud服务代码 一、关于pom.xml
除了一些基本包的导入之外，关于consul包的导入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、关于application.yml
1 2 3 4 5 6 7 8 9 10  spring: application: name: cloud-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name}   三、启动类添加@EnableDiscoveryClient注解。
consul测试 较为简单，访问localhost:8500查看即可。
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>Zookeeper配置过程与测试</title>
      <link>/posts/2022/07/zookeeper-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 12:00:37 +0800</pubDate>
      
      <guid>/posts/2022/07/zookeeper-configuration-process-and-test/</guid>
      <description>前言 Zookeeper类似于Eureka，起到微服务注册中心的作用，满足分布式系统中的CP原则，是弱可用性的。
配置zookeeper环境 安装zookeeper 下载并解压zookeeper包为zookeeper3.7.1（假设下载的是3.7.1版本）。
然后将zookeeper解压缩到/usr/local/zookeeper3.7.1。
配置参数 一、编辑/conf/zoo.cfg
编辑zookeeper包内配置文件/conf/zoo.cfg（先创建，再将zoo_sample.cfg内容复制到其中）
修改或添加以下内容：
1 2  dataDir=/usr/local/zookeeper3.7.1/dataDir dataLogDir=/usr/local/zookeeper3.7.1/dataLogDir   注意同时创建对应文件夹。其中端口号默认为2181，也可以进行修改。
二、 配置环境变量
1 2 3  # zookeeper export ZOOKEEPER_HOME=/usr/local/zookeeper3.7.1 export PATH=$PATH:$ZOOKEEPER_HOME/bin   接着通过source命令生效。
开启zookeeper连接 （前置条件是已配好java环境）
执行zkServer.sh start即可。
查看连接情况： 1 2 3 4 5 6  zkServer.sh status ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper3.7.1/bin/../conf/zoo.cfg Client port found: 2181. Client address: localhost. Client SSL: false. Mode: standalone   可见已经开启成功了。</description>
    </item>
    
    <item>
      <title>Eureka配置过程与理解</title>
      <link>/posts/2022/07/eureka-configuration-process-and-understanding/</link>
      <pubDate>Sun, 17 Jul 2022 11:39:35 +0800</pubDate>
      
      <guid>/posts/2022/07/eureka-configuration-process-and-understanding/</guid>
      <description>前言 起到微服务注册中心的作用，满足分布式系统中的AP原则，是弱一致性的。
Eureka微服务架构图  服务接口采用集群模式，8001和8002端口都实现支付接口服务。 用户接口在运行在80端口，调用8001和8002的服务。 注册中心内部也采用集群模式，7001和7002端口都实现注册服务。  引入Eureka依赖说明 client端：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   server端：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   7001和7002端口关键配置内容 一、启动类开启注解
1 2 3 4 5 6 7  @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class, args); } }   二、application.yml文件配置
对于7001端口服务：（7002端口类似）
1 2 3 4 5 6 7 8 9 10 11  eureka: instance: hostname: eureka7001.</description>
    </item>
    
    <item>
      <title>在前后端不分离的情况下进行交互性数据展示的实现方法</title>
      <link>/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/</link>
      <pubDate>Fri, 11 Feb 2022 00:05:25 +0800</pubDate>
      
      <guid>/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/</guid>
      <description>前言 开发web项目时，常常需要在前端展示一些交互性的数据，比如表单填写错误的提示，操作成功与否的提示等。
本文主要讲述在使用Thymeleaf作为模板引擎开发前端时，即在前后端不分离的情况下，前后端进行交互性数据展示的实现方法。
使用cookie传递数据：不推荐 一、步骤  后端通过addCookie方法设置值 前端在页面加载时读取cookie值并进行展示 前端删除该cookie值  二、缺陷 这个方法我使用过，但是效果并不好，原因如下：
 用户可能禁止cookie 后端如果有重定向操作将导致cookie添加失败 前端每次都要删除cookie，有时可能会失效  使用session传递数据：值得借鉴 一、步骤  后端往session中存入数据 前端通过${session}进行获取数据并展示 前端将该数据删除或修改为指定默认值  这里注意正常情况下js是无法操作或者访问session值的，我们可以通过thymeleaf内置脚本进行操作：
1 2 3  &amp;lt;script th:inline=&amp;#34;javascript&amp;#34;&amp;gt; // 这里可以通过session访问值 &amp;lt;/script&amp;gt;   二、缺陷 这个方法不好的地方显而易见，我们每次都要删除session值，而且只能通过内置脚本的方式操作，很不方便。
但是这种方法的思想值得借鉴，请看如下方法。
通过RedirectAttributesModelMap传递数据 注意这里后端采用SpringMVC。
一、步骤  通过RedirectAttributesModelMap往model中存值 返回视图对象，在视图对象中通过thymeleaf内置脚本进行数据展示  二、示例：提醒用户首先进行登录 1、后端代码： 1 2 3 4 5  @GetMapping(&amp;#34;/loginFirst&amp;#34;) public String loginFirst(RedirectAttributesModelMap model) { model.addFlashAttribute(&amp;#34;msg&amp;#34;, &amp;#34;请先进行登录&amp;#34;); return &amp;#34;redirect:/&amp;#34;; }     RedirectAttributesModelMap可以确保redirect后保存在model中数据不丢失</description>
    </item>
    
    <item>
      <title>Java重写equals方法的同时为什么要重写hashcode方法</title>
      <link>/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</link>
      <pubDate>Fri, 26 Nov 2021 09:23:27 +0800</pubDate>
      
      <guid>/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</guid>
      <description>提出问题 先看一个例子：
当两个人年龄相同时，我们认为这两个对象相同：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Person { private int age; private String name; public Person(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return &amp;#34;Person{&amp;#34; + &amp;#34;age=&amp;#34; + age + &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() !</description>
    </item>
    
    <item>
      <title>Java中通过反射获取带参数类型的方法</title>
      <link>/posts/2021/11/get-methods-with-parameter-types-through-reflection-in-java/</link>
      <pubDate>Wed, 17 Nov 2021 23:30:04 +0800</pubDate>
      
      <guid>/posts/2021/11/get-methods-with-parameter-types-through-reflection-in-java/</guid>
      <description>问题的提出 在后端与前端进行数据传送时，需要先把数据进行类型转换，从前端获得的字符串类型（由json类型数据转化而成），转换成一个Java类。通过了解，发现可以采用导入Gson包的方式调用方法实现这个功能：
1 2 3 4  Person p = new Person(1, &amp;#34;jzh&amp;#34;); Gson gson = new Gson(); String p_json = gson.toJson(p); Person p1 = gson.fromJson(p_json, Person.class);   从中可见gson.fromJson的第二个参数就是一个类对象，针对于无参的类可以直接通过.class获取类对象，然而有参怎么办呢？如下：
1 2 3 4 5 6 7  ArrayList&amp;lt;Person&amp;gt; people = new ArrayList&amp;lt;&amp;gt;(); people.add(new Person(1, &amp;#34;jzh&amp;#34;)); people.add(new Person(2, &amp;#34;zh&amp;#34;)); people.add(new Person(3, &amp;#34;z&amp;#34;)); String ps_json = gson.toJson(people); ArrayList&amp;lt;Person&amp;gt; people1 = gson.fromJson(ps_json,new TypeToken&amp;lt;ArrayList&amp;lt;Person&amp;gt;&amp;gt;() { }.getType());   这里通过创建匿名内部类的方式实现了转换，也可以通过创建类继承于TypeToken实现。
1 2 3  class MyType extends TypeToken&amp;lt;ArrayList&amp;lt;Person&amp;gt;&amp;gt; {} ArrayList&amp;lt;Person&amp;gt; people1 = gson.</description>
    </item>
    
    <item>
      <title>Linux上部署JAR包项目后的文件上传问题</title>
      <link>/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/</link>
      <pubDate>Wed, 03 Nov 2021 00:38:12 +0800</pubDate>
      
      <guid>/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/</guid>
      <description>在进行上传文件时，一般会先获取项目类路径：
1 2  File relativePathFile = new File(URLDecoder.decode(ResourceUtils.getURL(&amp;#34;classpath:&amp;#34;).getPath(), &amp;#34;utf-8&amp;#34;)); String absolutePath = relativePathFile.getAbsoluteFile().getPath();   首先取得相对路径，再进一步取得绝对路径，结果如下：
 如果单纯运行一个java项目：  获得路径为：
${project}/target/classes
 如果是运行jar包，且是在Linux系统上，则获得路径大致为：  .../${jar包名}!/BOOT-INF/classes! [centos7.9下]
所以如果是jar包启动并上传文件，则无法正确放到类路径下。
所以需指定新的上传路径。
在如下路径中：
1 2  [root@VM-0-11-centos app]# ls application.yaml LonersHub-0.0.1-SNAPSHOT.jar static   假设我要把文件上传到和jar包同一路径下的static内, 可以在jar包同一路径下新建并编辑application.yaml文件如下：
1 2 3 4 5  spring: resources: static-locations: - classpath:static/ - file:/app/static/   然后在文件上传是指定上传路径即可。
这里编写一个工具类如下：
关注getUploadPath方法，它用于获取上传路径。
首先，为了方便后期维护和部署使用，我们先判断项目运行所在的操作系统，如果是生产环境linux则上传到上面指定的目录，而如果是本地测试项目，则将其上传到类路径下的默认位置即可。
比如，要上传一个头像：
 linux下：  返回/app/static/${uploadType}/${fileName}
e.g. /app/static/avatar/test.jpg
 window下：  返回 ${project}/target/classes/static/${uploadType}/${fileName}</description>
    </item>
    
    <item>
      <title>Linux主机部署springboot项目全过程</title>
      <link>/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/</link>
      <pubDate>Wed, 03 Nov 2021 00:30:25 +0800</pubDate>
      
      <guid>/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/</guid>
      <description>注：部署环境为centos7.9版本
操作步骤如下：
 配置Java环境 配置mysql环境 配置redis环境 生成，上传并运行JAR包项目  配置Java环境 前往：Linux配置Java环境
配置mysql环境   配置mysql环境，前往：Linux配置Mysql环境
  建立数据库并新建表，可通过sql脚本快速建成。
  配置redis环境  安装redis：yum install redis 启动redis：systemctl start redis 默认启动在了6379端口，如需特殊指定可在/etc/redis.conf中修改默认配置 设置开机自启动redis：systemctl enable redis  生成，上传并运行JAR包项目 上传JAR包项目 1 2  mvn clean mvn package   即可把项目打包为JAR包，再通过WINSP上传到服务器。
先新建一个app文件夹，放置项目所有内容：
1 2  mkdir /app chmod 777 /app   新建并编辑application配置文件 由于主机上的mysql密码与本地mysql密码不同，所以在JAR包同一个文件目录下新建application配置文件并指定新的密码，允许JAR项目时该application配置文件优先级是更高的。这里我还指定了用于linux下文件读取上传的目录路径。
1 2 3 4 5 6 7  spring: datasource: password: ...... resources: static-locations: - classpath:static/ - file:/app/static/   1 2 3  [root@VM-0-11-centos app]# chmod -R 777 * [root@VM-0-11-centos app]# ls application.</description>
    </item>
    
    <item>
      <title>Linux配置Java环境</title>
      <link>/posts/2021/07/configuring-java-environment-for-linux/</link>
      <pubDate>Fri, 23 Jul 2021 20:49:56 +0800</pubDate>
      
      <guid>/posts/2021/07/configuring-java-environment-for-linux/</guid>
      <description>速通  ubuntu: /etc/bash.bashrc centos: /etc/bashrc  1 2 3 4 5 6 7 8 9 10  # jdk8.sh # 安装jdk-8u311-linux-x64并配好环境变量的脚本 tar -zxvf jdk-8u311-linux-x64.tar.gz mkdir /usr/local/java mv ./jdk1.8.0_311 /usr/local/java echo &amp;#39;# java env&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export JAVA_HOME=/usr/local/java/jdk1.8.0_311&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export PATH=$JAVA_HOME/bin:$PATH&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc source /etc/bash.bashrc   下文是分步解释。
获取JDK 首先下载jdk压缩包，然后解压缩jdk压缩包：
1 2 3 4 5 6  [root@VM-0-11-centos ~]# ls bin jdk-8u311-linux-x64.tar.gz passwd var [root@VM-0-11-centos ~]# tar -zxvf jdk-8u311-linux-x64.</description>
    </item>
    
    <item>
      <title>Synchronized到底锁了谁</title>
      <link>/posts/2021/05/who-the-hell-is-synchronized-locking/</link>
      <pubDate>Wed, 19 May 2021 22:43:45 +0800</pubDate>
      
      <guid>/posts/2021/05/who-the-hell-is-synchronized-locking/</guid>
      <description>Synchronized方法   静态方法上的锁
静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个类。
  普通方法上的锁
实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。在实例方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个对象实例。
  Synchronized代码块  synchronized(this){...}  this关键字所代表的意思是该对象实例，这种用法synchronized锁住的是对象实例。
 synchronized(Demo.class){...}  锁的是该类。
 synchronized(obj){...}  synchronized同步代码块对对象内部的实例加锁。
假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，均能获取各自的锁。
代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class Demo { private Object lock1 = new Object(); private Object lock2 = new Object(); public void demo1() { synchronized (lock1) { while (true) { //死循环目的是为了让线程一直持有该锁  System.</description>
    </item>
    
    <item>
      <title>Java与C&#43;&#43;中的值传递和引用传递解析</title>
      <link>/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</link>
      <pubDate>Sat, 01 May 2021 20:16:39 +0800</pubDate>
      
      <guid>/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</guid>
      <description>先说结论：Java只有值传递，而C++既有值传递又有引用传递。
Java的参数传递 先定义3个方法如下：
1 2 3 4 5 6 7 8 9 10 11  public static void change1(String str, int num) { str = &amp;#34;world&amp;#34;; // 这里就相当与新new了一个对象!  num = 100; } public static void change2(User user) { user.age = 1; user.name = &amp;#34;mary&amp;#34;; } public static void change3(User user) { user = new User(1, &amp;#34;mary&amp;#34;); }   进行测试：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void main(String[] args) { String str = &amp;#34;hello&amp;#34;; int num = 1; System.</description>
    </item>
    
    <item>
      <title>equals方法和==运算符的作用区别</title>
      <link>/posts/2020/11/the-difference-between-the-equals-method-and-the-operator/</link>
      <pubDate>Wed, 25 Nov 2020 00:21:05 +0800</pubDate>
      
      <guid>/posts/2020/11/the-difference-between-the-equals-method-and-the-operator/</guid>
      <description>equals方法与&amp;quot;==&amp;ldquo;的比较与分析 首先提出一个重要的点:
  == 比较时进行地址的比较
  equals 比较时进行值的比较
  1 2 3 4 5 6 7 8 9  String a = &amp;#34;123&amp;#34;; String b = &amp;#34;123&amp;#34;; System.out.println(a.equals(b)); // true System.out.println(a == b); // true  String a1 = new String(&amp;#34;123&amp;#34;); String b1 = new String(&amp;#34;123&amp;#34;); System.out.println(a1.equals(b1)); // true System.out.println(a1 == b1); // false   好像没问题。
然而阅读源码Object类，可以发现对象中默认equals方法进行的是地址的比较
1 2 3  public boolean equals(Object obj) { return (this == obj); }   再阅读源码String类，可以发现String类中重写了equals方法，覆盖掉了Object的equals方法，所以String的equals是值比较！</description>
    </item>
    
  </channel>
</rss>
