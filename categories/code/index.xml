<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code on Norwegian Wood</title>
    <link>/categories/code/</link>
    <description>Recent content in Code on Norwegian Wood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Jzh</copyright>
    <lastBuildDate>Fri, 29 Jul 2022 18:26:44 +0800</lastBuildDate><atom:link href="/categories/code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Zipkin使用记录</title>
      <link>/posts/2022/07/zipkin-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 18:26:44 +0800</pubDate>
      
      <guid>/posts/2022/07/zipkin-usage-record/</guid>
      <description>Zipkin的作用  查看微服务调用过程； 分析微服务依赖关系； 方便地找到调用过程错误发生位置。  Zipkin使用记录 一、下载Zipkin并运行：
1  java -jar zipkin.jar   这样成功运行后，默认在端口9411可以查看图形管理界面。
二、依赖引入
在所有调用到的微服务中引入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   三、配置文件
1 2 3 4 5 6  spring: zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 # 采样率介于0和1之间，1表示全部采集   测试 通过service-name标签搜索自己的微服务名称，即可检索到与该微服务有依赖的所有微服务，可查看调用过程，依赖关系等。
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>SpringCloud-Stream使用记录</title>
      <link>/posts/2022/07/springcloud-stream-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 17:26:05 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-stream-usage-record/</guid>
      <description>为何使用Stream？ 实现消息的收发可以用许多种方式来实现，如Kafka，RabbitMQ等，而通过Stream可以方便地通过一个Binder对象与这些不同的实现工具对接，应用程序通过Inputs和Outputs来与Binder交互即可实现消息的收发，这样我们就只需要知道如何与Stream交互即可方便地使用消息驱动。
下图即Stream工作原理：
Stream使用记录 一、依赖导入 除去一些基本依赖之外，发布端和订阅端均导入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-stream-rabbit&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、基本配置 发布端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: output: destination: myExchange content-type: application/json binder: defaultRabbit   订阅端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: input: destination: myExchange content-type: application/json binder: defaultRabbit group: jzh1   注意，两个订阅端如果实现同一微服务，group应该一样，这样，在同一个组内会发生竞争关系，只有其中一个可以消费（默认采用轮询的机制处理），避免了出现重复消费的问题。</description>
    </item>
    
    <item>
      <title>Config结合Bus使用记录</title>
      <link>/posts/2022/07/config-combined-with-bus-usage-record/</link>
      <pubDate>Wed, 27 Jul 2022 22:00:55 +0800</pubDate>
      
      <guid>/posts/2022/07/config-combined-with-bus-usage-record/</guid>
      <description>为何要使用Config和Bus Config可以进行多个微服务下的全局配置，更加方便，易于管理。
当全局配置修改时，需要通知各个微服务，一个一个地通知是非常耗时的，如果可以通过广播的方式快速将消息传递出去就轻松多了，而通过Bus即可实现这一点。
测试方法 一、在6996端口通过git拉取全局配置，相当于一个ConfigServer，6886和6776端口作为ConfigClient；
二、Bus结合RabbitMQ实现，修改配置时，只通知ConfigServer，达到消息广播的效果。
依赖引入 一、ConfigServer端：
1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、ConfigClient端：
1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   其他一些基本包就省略了。
文件配置 一、ConfigServer端：
以下为application.yml:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  spring: cloud: config: server: git: # github项目地址 uri: https://github.</description>
    </item>
    
    <item>
      <title>SpringCloud-Gateway使用记录</title>
      <link>/posts/2022/07/springcloud-gateway-usage-record/</link>
      <pubDate>Tue, 26 Jul 2022 18:33:44 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-gateway-usage-record/</guid>
      <description>网关的作用 如图所示，网关介于外部请求和具体微服务之间，在不暴露内部微服务端口的情况下，通过一个或者多个指定的网关端口统一地处理外部各种请求。
使用SpringCloud Gateway 依赖引入 除了基本依赖以外，引入下列依赖：
1 2 3 4 5 6 7 8 9  &amp;lt;!-- others --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   注意不能引入web相关依赖，因为Gateway是基于WebFlux的。
文件配置 列出部分重要配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14  server: port: 9669 cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: path_route uri: lb://CLOUD-PAYMENT-SERVICE # lb：负载均衡 predicates: - Path=/payment/** - After=2022-07-26T17:33:52.</description>
    </item>
    
    <item>
      <title>Hystrix实现服务熔断与监控</title>
      <link>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</link>
      <pubDate>Tue, 26 Jul 2022 11:39:11 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</guid>
      <description>什么是服务熔断 概念 应对微服务雪崩效应的一种链路保护机制，类似保险丝。
关于雪崩效应 微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务C，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应。
实现机制 当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。
通过Hystrix实现服务熔断，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，就会启动熔断机制，断路器打开。而在一段时间之后，断路器会变为半开状态，此时允许部分微服务调用，如果都成功了，即不超过设定好的阈值，那么断路器将恢复为关闭状态。
如下图所示：（来自Martin Fowler大神的博客）
应用场景 微服务架构中，多个微服务相互调用出使用
Hystrix实现服务熔断 环境搭建 1. 关于pom.xml 1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   2. 启动类添加@EnableHystrix注解，表示使用熔断器。 实现服务熔断 1. PaymentService.java 1 2 3 4  public interface PaymentService { ... String circuitBreaker(Integer id); }   2. PaymentServiceImpl.java 设置服务熔断的核心配置：
（1）启用断路器:
1  @HystrixProperty(name = &amp;#34;circuitBreaker.enabled&amp;#34;, value = &amp;#34;true&amp;#34;)   （2）设置请求次数:</description>
    </item>
    
    <item>
      <title>Hystrix实现服务降级</title>
      <link>/posts/2022/07/hytrix-enables-service-degradation/</link>
      <pubDate>Tue, 26 Jul 2022 10:59:08 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-enables-service-degradation/</guid>
      <description>什么是服务降级 概念 一般指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而释放服务器资源的资源以保证核心业务的正常高效运行。
应用场景 多用于微服务架构中，一般当整个微服务架构整体的负载超出了预设的上限阈值（和服务器的配置性能有关系），或者即将到来的流量预计会超过预设的阈值时。
大致实现过程 为了预防某些功能出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。
使用Hystrix实现服务降级 本实验配合了Feign实现，利用Feign通过接口的方式解耦服务这一特点，通过在实现服务接口的类来编写方法对应的fallback方法。
环境搭建 一、关于pom
在消费方实现服务降级，除了基本包导入外，导入以下：
1 2 3 4 5 6 7 8 9 10 11 12  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、关于application.yml
除了基本配置外，以下两个超时时间的配置需要格外注意：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 设置feign超时时间（默认为1秒） feign: hystrix: enabled: true client: config: default: ConnectTimeOut: 5000 ReadTimeOut: 5000 # 设置hystrix超时时间（默认为1秒） hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000   其他关于Feign的环境配置省略了。</description>
    </item>
    
    <item>
      <title>Linux实用操作之系统服务管理</title>
      <link>/posts/2022/07/system-service-management-of-linux-practical-operation/</link>
      <pubDate>Sun, 24 Jul 2022 20:42:27 +0800</pubDate>
      
      <guid>/posts/2022/07/system-service-management-of-linux-practical-operation/</guid>
      <description>systemctl指令  立即启动一个服务：systemctl start my.service 立即停止一个服务：systemctl stop my.service 重启一个服务：systemctl restart my.service 重新加载一个服务的配置文件：systemctl reload my.service 重载所有修改过的配置文件：systemctl daemon-reload 开启自启动服务：systemctl enable my.service 取消开启自启动：systemctl disable my.service 查看是否已经自启动：systemctl is-enabled my.service 查看服务运行状态：systemctl status my.service 查看所有服务：systemctl --type service  service和chkconfig指令  启动服务：service my.service start 终止服务：service my.service stop 重启服务：service my.service restart 查看服务运行状态：service my.service status 开启或取消开机自启动：chkconfig my.service on/off 查看开机自启动列表：chkconfig --list  Unit配置文件解释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  - Unit - Description，服务的描述 - Requires，定义此unit需在哪个daemon启动后才能够启动 - Service - Type，定义启动时的进程行为。它有以下几种值。 - Type=simple，默认值，执行ExecStart指定的命令，启动主进程 - Type=forking，以 fork 方式从父进程创建子进程，创建后父进程会立即退出 - Type=oneshot，一次性进程，Systemd 会等当前服务退出，再继续往下执行 - Type=dbus，当前服务通过D-Bus启动 - Type=notify，当前服务启动完毕，会通知Systemd，再继续往下执行 - Type=idle，若有其他任务执行完毕，当前服务才会运行 - ExecStart，启动当前服务的命令 - ExecStartPre，启动当前服务之前执行的命令 - ExecStartPost，启动当前服务之后执行的命令 - ExecReload，重启当前服务时执行的命令 - ExecStop，停止当前服务时执行的命令 - ExecStopPost，停止当其服务之后执行的命令 - RestartSec，自动重启当前服务间隔的秒数 - Restart，定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog - TimeoutSec，定义 Systemd 停止当前服务之前等待的秒数 - Environment，指定环境变量 - Install - WantedBy，值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.</description>
    </item>
    
    <item>
      <title>Linux配置Mysql环境</title>
      <link>/posts/2022/07/configuring-mysql-environment-for-linux/</link>
      <pubDate>Sat, 23 Jul 2022 21:27:15 +0800</pubDate>
      
      <guid>/posts/2022/07/configuring-mysql-environment-for-linux/</guid>
      <description>安装mysql yum方式安装mysql 一、获取mysql的rpm包
可从地址：https://dev.mysql.com/downloads/repo/yum/
找到适合自己发行版本的rpm包下载。下面下载的是适用于CentOS7版本的。
1 2 3  [root@VM-0-11-centos ~]# wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm ...... 2022-01-02 12:07:24 (133 KB/s) - ‘mysql80-community-release-el7-3.noarch.rpm’ saved [26024/26024]   二、安装mysql的rpm包
1 2 3 4  [root@VM-0-11-centos ~]# rpm -Uvh mysql80-community-release-el7-3.noarch.rpm ...... Updating / installing... 1:mysql80-community-release-el7-3 ################################# [100%]   这时查看/etc/yum.repos.d即可以看到如下内容：
1 2 3  [root@VM-0-11-centos ~]# ls /etc/yum.repos.d | grep mysql mysql-community.repo mysql-community-source.repo   三、（可选）将mysql80换为mysql57
1 2 3 4 5 6 7 8  [root@VM-0-11-centos ~]# yum-config-manager --disable mysql80-community [root@VM-0-11-centos ~]# yum-config-manager --enable mysql57-community # 查看是否切换成功： [root@VM-0-11-centos ~]# yum repolist enabled | grep mysql mysql-connectors-community/x86_64 MySQL Connectors Community 221 mysql-tools-community/x86_64 MySQL Tools Community 135 mysql57-community/x86_64 MySQL 5.</description>
    </item>
    
    <item>
      <title>Wsl主要操作记录</title>
      <link>/posts/2022/07/wsl-main-operation-records/</link>
      <pubDate>Sat, 23 Jul 2022 17:34:52 +0800</pubDate>
      
      <guid>/posts/2022/07/wsl-main-operation-records/</guid>
      <description>wsl在window开机后自启ssh服务   wsl下创建脚本，执行：vim /etc/init.wsl，并根据需要写入服务：
1  /etc/init.d/${需要的服务} # 或者使用service/systemctl命令   再赋予init.wsl执行权限，执行：chmod +x /etc/init.wsl
  window下在启动目录下创建脚本：wsl.bat，写入开机命令如下：
1  wsl -d &amp;lt;DistributionName&amp;gt; -u root /etc/init.wsl   其中，版本通过wsl -l查看。
  wsl一些常用命令  wsl ~ -u jzh: 以jzh用户登录并进入用户文件夹 wsl --shutdown: 关闭wsl wsl -l -v: 查看已安装的wsl版本 wsl --status: 检查wsl状态 wsl -l --online: 查看可通过在线商店获得的 Linux 发行版列表  wsl修改默认登录用户 &amp;lt;DistributionName&amp;gt; config --default-user root: 将登录默认用户设为root
手动安装wsl的话可能无法生效，可通过修改/etc/wsl.conf完成：
1 2 3  # Set the user when launching a distribution with WSL.</description>
    </item>
    
    <item>
      <title>OpenFeign使用记录</title>
      <link>/posts/2022/07/openfeign-usage-record/</link>
      <pubDate>Fri, 22 Jul 2022 17:39:24 +0800</pubDate>
      
      <guid>/posts/2022/07/openfeign-usage-record/</guid>
      <description>为什么要使用OpenFeign 之前在消费端使用RestTemplate时，每次请求都要进行诸如
1  restTemplate.postForObject(PAYMENT_URL + &amp;#34;/payment/create&amp;#34;, payment, CommonResult.class);   这样的调用，需要指定较多参数，当一个接口调用中需要非常多这样的请求时，会比较繁琐，而且这种方式不够抽象。
OpenFegin利用面向接口编程的思想，抽象化，简化了上述操作。
使用OpenFeign 关于pom.xml 1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   关于application.yml 除了基本配置内容外，注意以下配置：
1 2 3 4 5 6 7 8 9 10 11  feign: # 设置feign客户端超时时间（默认为1秒） client: config: default: ConnectTimeOut: 10000 ReadTimeOut: 10000 # 针对每个接口设置日志监控级别 logging: level: com.jzh.springcloud.service.PaymentService: debug # feign日志以什么级别监控端口   编写服务接口 首先在启动类开启@EnableFeignClients注解，接着编写服务接口：
 添加@FeignClient注解，值为对应微服务名； 方法对应微服务Controller下的方法即可。  1 2 3 4 5 6 7 8 9  @Component @FeignClient(value = &amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;) public interface PaymentService { @GetMapping(&amp;#34;/payment/get/{id}&amp;#34;) CommonResult&amp;lt;Payment&amp;gt; getPaymentById(@PathVariable(&amp;#34;id&amp;#34;) Long id); @PostMapping(&amp;#34;/payment/create&amp;#34;) CommonResult&amp;lt;Integer&amp;gt; createPayment(@RequestBody Payment payment); }   调用接口 注入PaymentController接口，然后即可调用它的方法。</description>
    </item>
    
    <item>
      <title>理解快速幂运算并进行应用</title>
      <link>/posts/2022/07/understand-and-apply-fast-power-operation/</link>
      <pubDate>Thu, 21 Jul 2022 20:44:54 +0800</pubDate>
      
      <guid>/posts/2022/07/understand-and-apply-fast-power-operation/</guid>
      <description>快速幂运算的解释 问n是否满足$x^n \mod n = x (1 &amp;lt; x &amp;lt; n)$？
先由一个例子引入：
$3^{11} = 3 \times 9^5 = 3 \times 9 \times 81^2 = 3 \times 9 \times 6561^1$
$result = 3 \times 9 \times 6561 = 3^{2^0} \times 3^{2^1} \times 3^{2^3}$
可见发现这次运算中，幂的结果等于变化中所有当指数为奇数时底数之积。其中，每次运算均发生指数除二（对应二进制右移一位），且当该指数为奇数时，原式乘上底数。
而这个过程其实相当于一个数进行模2取余求二进制数的过程，每次都除2，当模2余1，即对应二进制最末位为1时乘上底数，则由此可以推知快速幂运算的算法过程。
这个结论是可以证明的，如下：
对于任何十进制正整数n，设其对应二进制数为&amp;quot;$b_m&amp;hellip;b_3b_2b_1$&amp;quot;，则有：
 二进制转十进制：$n = 1b_1+2b_2+4b_3+&amp;hellip;+2^{m-1}b_m$； 幂的二进制展开：$x^n = x^{1b_1}x^{2b_2}x^{4b_3}&amp;hellip;x^{2^{m-1}b_m}$。  则对于$x^n$的求解，可以转化为：
 计算$x^1,x^2,x^4&amp;hellip;x^{m-1}$的值，相当于$x=x^2$的过程； 获取二进制各位$b_1,b_2,b_3,&amp;hellip;,b_m$的值，相当于模2求余的过程。  上述过程中，当$b_i=0$时，$x^{2^{i-1}b_i}=1$，反之为$x^{2^{i-1}}$，由此可以顺利计算$x^n$。
相应代码：
1 2 3 4 5 6 7 8 9 10  typedef long long ll; ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while(n &amp;gt; 0) { if(n &amp;amp; 1 == 1) res = res * x % mod; // 一个数&amp;amp;1的结果就是取该数二进制的最末位 	x = x * x % mod; n &amp;gt;&amp;gt;= 1; }	return res; }   注意，运用位运算可以提高效率！</description>
    </item>
    
    <item>
      <title>理解Ribbon并自己实现负载均衡</title>
      <link>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</link>
      <pubDate>Wed, 20 Jul 2022 17:07:35 +0800</pubDate>
      
      <guid>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</guid>
      <description>负载均衡（LB）是什么 对于用户的某个请求，将有多个相同功能的服务点服务该请求，某个服务点挂了，其他服务点还是可以进行服务，这样就实现了系统的高可用。
关于集中式LB和进程内LB 集中式LB 在服务的消费方和提供方之间使用独立的LB设施，（软硬件均可，软件如Nginx，硬件如F5），由该设施负责把访问请求通过某种策略（可自行指定）转发至服务的提供方。
进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务点进行服务。
Ribbon属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它获取服务提供方的地址。
使用Ribbon实现负载均衡 关于导包 1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 已经包含了ribbon --&amp;gt; &amp;lt;/dependency&amp;gt;   注意eureka内置了ribbon。
开启注解 1 2 3 4 5 6 7 8  @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 赋予负载均衡能力  public RestTemplate getRestTemplate() { return new RestTemplate(); } }   访问相同服务名地址即可。
修改Ribbon负载均衡规则 所有规则均实现了IRule接口，通过查看接口实现类即可知道规则的种类。
默认是RoundRobinRule（轮询）这一规则。
下面修改为RandomRule（随机）这一规则：
在启动类扫描不到的包下创建规则： 1 2 3 4 5 6 7  @Configuration public class MyRibbonRule { @Bean public IRule myRule() { return new RandomRule(); } }   在启动类指定规则： 1 2 3 4 5 6 7 8  @SpringBootApplication @EnableEurekaClient @RibbonClient(name=&amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;, configuration = MyRibbonRule.</description>
    </item>
    
    <item>
      <title>Consul配置过程及测试</title>
      <link>/posts/2022/07/consul-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 16:34:39 +0800</pubDate>
      
      <guid>/posts/2022/07/consul-configuration-process-and-test/</guid>
      <description>前言 类似于zookeeper和eureka，也起到微服务注册中心的作用, 满足分布式系统中的CP原则，是弱可用性的。
不同于zookeeper和eureka这两种主要由Java编写的语言，它主要由Go语言编写。
配置Consul环境  下载consul，配置环境变量。 运行consul agent -dev开启服务。 默认端口为8500，访问localhost:8500进入管理界面。  编写springcloud服务代码 一、关于pom.xml
除了一些基本包的导入之外，关于consul包的导入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、关于application.yml
1 2 3 4 5 6 7 8 9 10  spring: application: name: cloud-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name}   三、启动类添加@EnableDiscoveryClient注解。
consul测试 较为简单，访问localhost:8500查看即可。
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>Zookeeper配置过程与测试</title>
      <link>/posts/2022/07/zookeeper-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 12:00:37 +0800</pubDate>
      
      <guid>/posts/2022/07/zookeeper-configuration-process-and-test/</guid>
      <description>前言 Zookeeper类似于Eureka，起到微服务注册中心的作用，满足分布式系统中的CP原则，是弱可用性的。
配置zookeeper环境 安装zookeeper 下载并解压zookeeper包为zookeeper3.7.1（假设下载的是3.7.1版本）。
然后将zookeeper解压缩到/usr/local/zookeeper3.7.1。
配置参数 一、编辑/conf/zoo.cfg
编辑zookeeper包内配置文件/conf/zoo.cfg（先创建，再将zoo_sample.cfg内容复制到其中）
修改或添加以下内容：
1 2  dataDir=/usr/local/zookeeper3.7.1/dataDir dataLogDir=/usr/local/zookeeper3.7.1/dataLogDir   注意同时创建对应文件夹。其中端口号默认为2181，也可以进行修改。
二、 配置环境变量
1 2 3  # zookeeper export ZOOKEEPER_HOME=/usr/local/zookeeper3.7.1 export PATH=$PATH:$ZOOKEEPER_HOME/bin   接着通过source命令生效。
开启zookeeper连接 （前置条件是已配好java环境）
执行zkServer.sh start即可。
查看连接情况： 1 2 3 4 5 6  zkServer.sh status ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper3.7.1/bin/../conf/zoo.cfg Client port found: 2181. Client address: localhost. Client SSL: false. Mode: standalone   可见已经开启成功了。</description>
    </item>
    
    <item>
      <title>Eureka配置过程与理解</title>
      <link>/posts/2022/07/eureka-configuration-process-and-understanding/</link>
      <pubDate>Sun, 17 Jul 2022 11:39:35 +0800</pubDate>
      
      <guid>/posts/2022/07/eureka-configuration-process-and-understanding/</guid>
      <description>前言 起到微服务注册中心的作用，满足分布式系统中的AP原则，是弱一致性的。
Eureka微服务架构图  服务接口采用集群模式，8001和8002端口都实现支付接口服务。 用户接口在运行在80端口，调用8001和8002的服务。 注册中心内部也采用集群模式，7001和7002端口都实现注册服务。  引入Eureka依赖说明 client端：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   server端：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   7001和7002端口关键配置内容 一、启动类开启注解
1 2 3 4 5 6 7  @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class, args); } }   二、application.yml文件配置
对于7001端口服务：（7002端口类似）
1 2 3 4 5 6 7 8 9 10 11  eureka: instance: hostname: eureka7001.</description>
    </item>
    
    <item>
      <title>Window添加命令别名的方法</title>
      <link>/posts/2022/06/how-to-add-command-alias-in-window/</link>
      <pubDate>Fri, 24 Jun 2022 22:52:59 +0800</pubDate>
      
      <guid>/posts/2022/06/how-to-add-command-alias-in-window/</guid>
      <description>前言 下面将介绍3种方法：
 CMD添加别名的方法 PowerShell添加别名的方法 通过添加环境变量的方式设置别名  CMD添加别名的方法 设置临时的别名 可以通过doskey命令实现。
1  doskey ls=echo ====== ^&amp;amp;^&amp;amp; dir /b $* ^&amp;amp;^&amp;amp; echo ======   $*表示还可能有其他命令参数，^&amp;amp;^&amp;amp;用于分开多条命令。
单纯在一个cmd窗口中使用doskey设置别名，别名只能在该窗口中使用。
设置永久的别名 可以通过将doskey命令写入bat脚本，再把脚本路径添加到注册表Autorun实现永久且所有cmd都可用的别名，具体步骤如下：
 编写脚本：  1 2 3  @echo off doskey ls=dir /b $* doskey lss=echo ====== ^&amp;amp;^&amp;amp; dir /b $* ^&amp;amp;^&amp;amp; echo ======   添加路径到注册表  在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor下的Autorun中，将数值设为doskey命令脚本所在的路径即可。这样所有用户都可以使用设置好的别名。
也可在HKEY_CURRENT_USER下的对应位置设置，只针对当前用户设置别名。
优缺点 通过doskey的方式，挺方便的，但是在命令非常多的情况下不是很方便，同时，设置的命令还不可以在powershell下运行。
PowerShell添加别名的方法 为PowerShell设置临时的别名 1 2 3  PS C:\Users\akyna&amp;gt; set-alias escc esc PS C:\Users\akyna&amp;gt; escc .</description>
    </item>
    
    <item>
      <title>使用x86_64汇编写一个自旋锁</title>
      <link>/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/</link>
      <pubDate>Thu, 09 Jun 2022 23:37:51 +0800</pubDate>
      
      <guid>/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/</guid>
      <description>一、理论分析 自旋锁，顾名思义，即自己不断旋转重复进行的锁，当多个线程访问同一资源时，为实现互斥访问，必须给目标资源加锁，此时只允许一个线程访问，此时其他线程无法访问，并且一直重复请求访问，直到该锁被释放。访问完资源的线程及时释放锁以供其他资源访问。
自旋锁可以通过比较替换算法实现：设锁为1时被占用，为0时空闲。当一个线程请求锁时，即进入请求锁循环“spinlock”，设预期值为0，修改值为1，让锁值与预期值比较，若锁值等于预期值，则锁空闲，将锁值置为修改值，退出spinlock循环；若锁值不等于预期值，则证明锁被占用，继续spinlock循环。
为验证是否成功实现自旋，开启一个释放锁线程，请求锁线程自旋一段时间后，释放锁线程进行锁的释放，即把锁值置为预期值0。此时，请求锁线程成功获得锁并退出spinlock循环。
二、设计与实现 使用x86_64汇编实现自旋锁：
Intel语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // 尝试获取锁 void lock(long *p) { long a = 0, c = 1; printf(&amp;#34;try to get lock...\n&amp;#34;); __asm__( &amp;#34;push rax \n\t&amp;#34; &amp;#34;push rcx \n\t&amp;#34; &amp;#34;spin_lock: \n\t&amp;#34; &amp;#34;mov rcx, %[c] \n\t&amp;#34; &amp;#34;mov rax, %[a] \n\t&amp;#34; // 比较并替换算法，若p==rax==0则获得锁并使p=rcx(==1)，若p(==1)!</description>
    </item>
    
    <item>
      <title>通过Wireshark分析TCP原理</title>
      <link>/posts/2022/06/analyze-tcp-principle-through-wireshark/</link>
      <pubDate>Thu, 09 Jun 2022 23:18:55 +0800</pubDate>
      
      <guid>/posts/2022/06/analyze-tcp-principle-through-wireshark/</guid>
      <description>使用Wireshark作为抓包工具，通过ftp文件上传过程分析tcp原理，主要分析过程包括三次握手建立连接的过程，文件传输的过程，四次挥手断开连接的过程。
设备信息  主机：安装了ftp的window11（ip:172.23.224.1） 虚拟机：安装了vsftpd的wsl2（ubuntu18）(ip:172.23.234.65)  操作与分析过程 打开Wireshark进行捕获  选择**vEthernet(WSL)**连接进行捕获。 使用过滤表达式ip.addr==172.23.234.65&amp;amp;&amp;amp;tcp进行捕获。  通过ftp上传文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14  PS C:\Users\akyna&amp;gt; ftp 172.23.234.65 连接到 172.23.234.65。 220 (vsFTPd 3.0.3) 200 Always in UTF8 mode. 用户(172.23.234.65:(none)): akyna 331 Please specify the password. 密码: 230 Login successful. ftp&amp;gt; put a.txt 200 PORT command successful. Consider using PASV. 150 Ok to send data. 226 Transfer complete.</description>
    </item>
    
    <item>
      <title>Window实用命令记录之进程与网络控制</title>
      <link>/posts/2022/04/process-and-network-control-of-window-practical-command-recording/</link>
      <pubDate>Mon, 18 Apr 2022 23:10:39 +0800</pubDate>
      
      <guid>/posts/2022/04/process-and-network-control-of-window-practical-command-recording/</guid>
      <description>进程相关 tasklist  tasklist用于查看运行的进程 findstr相当于linux的grep  1 2 3 4  PS C:\Users\akyna&amp;gt; Tasklist | findstr Code Code.exe 19184 Console 1 94,012 K Code.exe 19300 Console 1 26,324 K ......   taskkill 使用该工具按照进程 ID (PID) 或映像名称终止任务。
参数列表:
 /PID processid 指定要终止的进程的 PID。 /IM imagename 指定要终止的进程的映像名称。 /T 终止指定的进程和由它启用的子进程。 /F 指定强制终止进程。 /? 显示帮助消息。  e.g.
1 2 3  TASKKILL /IM notepad.exe TASKKILL /PID 1230 /PID 1241 /PID 1253 /T TASKKILL /F /IM cmd.</description>
    </item>
    
    <item>
      <title>在前后端不分离的情况下进行交互性数据展示的实现方法</title>
      <link>/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/</link>
      <pubDate>Fri, 11 Feb 2022 00:05:25 +0800</pubDate>
      
      <guid>/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/</guid>
      <description>前言 开发web项目时，常常需要在前端展示一些交互性的数据，比如表单填写错误的提示，操作成功与否的提示等。
本文主要讲述在使用Thymeleaf作为模板引擎开发前端时，即在前后端不分离的情况下，前后端进行交互性数据展示的实现方法。
使用cookie传递数据：不推荐 一、步骤  后端通过addCookie方法设置值 前端在页面加载时读取cookie值并进行展示 前端删除该cookie值  二、缺陷 这个方法我使用过，但是效果并不好，原因如下：
 用户可能禁止cookie 后端如果有重定向操作将导致cookie添加失败 前端每次都要删除cookie，有时可能会失效  使用session传递数据：值得借鉴 一、步骤  后端往session中存入数据 前端通过${session}进行获取数据并展示 前端将该数据删除或修改为指定默认值  这里注意正常情况下js是无法操作或者访问session值的，我们可以通过thymeleaf内置脚本进行操作：
1 2 3  &amp;lt;script th:inline=&amp;#34;javascript&amp;#34;&amp;gt; // 这里可以通过session访问值 &amp;lt;/script&amp;gt;   二、缺陷 这个方法不好的地方显而易见，我们每次都要删除session值，而且只能通过内置脚本的方式操作，很不方便。
但是这种方法的思想值得借鉴，请看如下方法。
通过RedirectAttributesModelMap传递数据 注意这里后端采用SpringMVC。
一、步骤  通过RedirectAttributesModelMap往model中存值 返回视图对象，在视图对象中通过thymeleaf内置脚本进行数据展示  二、示例：提醒用户首先进行登录 1、后端代码： 1 2 3 4 5  @GetMapping(&amp;#34;/loginFirst&amp;#34;) public String loginFirst(RedirectAttributesModelMap model) { model.addFlashAttribute(&amp;#34;msg&amp;#34;, &amp;#34;请先进行登录&amp;#34;); return &amp;#34;redirect:/&amp;#34;; }     RedirectAttributesModelMap可以确保redirect后保存在model中数据不丢失</description>
    </item>
    
    <item>
      <title>Linux实用操作之权限管理</title>
      <link>/posts/2021/12/permission-management-of-linux-practical-operation/</link>
      <pubDate>Mon, 20 Dec 2021 10:15:34 +0800</pubDate>
      
      <guid>/posts/2021/12/permission-management-of-linux-practical-operation/</guid>
      <description>添加用户 1 2 3 4 5 6 7 8 9  [root@VM-0-11-centos ~]# useradd jzh [root@VM-0-11-centos /]# id jzh uid=1000(jzh) gid=1000(jzh) groups=1000(jzh) [root@VM-0-11-centos /]# grep jzh /etc/passwd /etc/shadow /etc/group /etc/passwd:jzh:x:1000:1000::/home/jzh:/bin/bash /etc/shadow:jzh:!!:18980:0:99999:7::: /etc/group:jzh:x:1000:   x指代密码，对应到shadow中，未设定即为“!!”
设置密码 在进行useradd后密码还未设定。
1 2 3 4 5 6  [root@VM-0-11-centos /]# passwd jzh Changing password for user jzh. New password: BAD PASSWORD: The password is shorter than 8 characters Retype new password: passwd: all authentication tokens updated successfully.</description>
    </item>
    
    <item>
      <title>Redis学习记录二</title>
      <link>/posts/2021/12/redis-learning-record-ii/</link>
      <pubDate>Mon, 20 Dec 2021 10:15:05 +0800</pubDate>
      
      <guid>/posts/2021/12/redis-learning-record-ii/</guid>
      <description>事务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  127.0.0.1:6379&amp;gt; multi # 开启事务 OK 127.0.0.1:6379&amp;gt; set book java QUEUED 127.0.0.1:6379&amp;gt; get book QUEUED 127.0.0.1:6379&amp;gt; exec # 执行事务 1) OK 2) &amp;#34;java&amp;#34; 127.0.0.1:6379&amp;gt; get book &amp;#34;java&amp;#34; 127.0.0.1:6379&amp;gt; multi OK 127.0.0.1:6379&amp;gt; set name peter QUEUED 127.0.0.1:6379&amp;gt; discard # 取消事务 OK 127.0.0.1:6379&amp;gt; exec (error) ERR EXEC without MULTI 127.0.0.1:6379&amp;gt; get name (nil)   获取key 获取指定key 1  keys * # 获取所有key   1  keys pattern # 根据pattern获取key   1 2 3 4  - * 代表匹配任意字符 - ?</description>
    </item>
    
    <item>
      <title>Redis学习记录一</title>
      <link>/posts/2021/12/redis-learning-record-i/</link>
      <pubDate>Tue, 14 Dec 2021 23:40:44 +0800</pubDate>
      
      <guid>/posts/2021/12/redis-learning-record-i/</guid>
      <description>Open, Connect And Config  open redis:  1  redis-server   connect to redis:  1  redis-cli   disconnect:  1  redis-cli shutdown   show chinese:  1  redis-cli --raw   connect to remote redis:  1  redis-cli -h host -p port -a password   get redis config:  1  config get {config_name}   Data Type list:
1 2 3  lpush clist redis lpush clist mysql lrange clist 0 100   key:</description>
    </item>
    
    <item>
      <title>Git实用操作之初始化与分支管理</title>
      <link>/posts/2021/12/initialization-and-branch-management-of-git-practical-operations/</link>
      <pubDate>Fri, 10 Dec 2021 18:10:07 +0800</pubDate>
      
      <guid>/posts/2021/12/initialization-and-branch-management-of-git-practical-operations/</guid>
      <description>git初次拉取远程仓库  从github建立一个仓库，获取仓库地址url 进入项目所在文件夹，运行一下代码  1 2 3 4 5 6 7 8 9  &amp;gt; git init # 初始化仓库，生成.git文件 &amp;gt; git add . # 将项目文件的修改信息添加到.git内的一个暂存区（index） &amp;gt; git commit -m “init” # 将暂存区的修改信息提交到分支 &amp;gt; git remote add origin ${url} # 添加远程仓库 &amp;gt; git push origin master # 将本地分支推送到远程仓库   这里执行完 git commit -m “init”后，我们查看一下本地分支信息：
1 2  &amp;gt; git branch * master   可见git自动为我们本地创建了一个master分支。
执行完git push origin master后，我们查看一下本地分支与远程分支的映射关系：</description>
    </item>
    
    <item>
      <title>Linux实用操作之流程控制</title>
      <link>/posts/2021/12/process-control-of-linux-practical-operation/</link>
      <pubDate>Thu, 09 Dec 2021 20:33:45 +0800</pubDate>
      
      <guid>/posts/2021/12/process-control-of-linux-practical-operation/</guid>
      <description>读取输入  read -a variable_name 读取数组”array”  1 2 3 4 5 6  [root@VM-0-11-centos tmp]# read -a arr 1 2 3 4 5 [root@VM-0-11-centos tmp]# echo ${arr[0]} 1 [root@VM-0-11-centos tmp]# echo ${arr[4]} 5    read -p “prompt words” variable_name read -n limit_length variable_name  1 2 3  [root@VM-0-11-centos tmp]# read -n 5 kk words[root@VM-0-11-centos tmp]# echo $kk words    read -s variable_name “silent”输入不显示 read -t time variable_name “time”限定时间输入  条件判断语句 if else 1 2 3 4 5 6 7 8 9  if [] then do something elif [] then do something else do something fi   case 1 2 3 4 5 6 7 8 9 10 11  case ${var} in &amp;#34;condition1&amp;#34;) do something ;; &amp;#34;condition2&amp;#34;) do something ;; *) #anything do something ;; esac   循环语句 while 1 2 3 4  while [condition] do do something done   when meet the condition, start the loop.</description>
    </item>
    
    <item>
      <title>关于char*, char[], string的理解</title>
      <link>/posts/2021/12/understanding-of-char-char-string/</link>
      <pubDate>Sun, 05 Dec 2021 12:37:32 +0800</pubDate>
      
      <guid>/posts/2021/12/understanding-of-char-char-string/</guid>
      <description>关于char[]与char*的区别 1 2 3 4  char s1[] = &amp;#34;abc&amp;#34;; cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // abc s1[1] = &amp;#39;d&amp;#39;; // 改变值 cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // adc   &amp;ldquo;abc&amp;quot;为字符串常量，s1为指针常量，即指针是一个常量，所以指向地址不能改变，指向地址的值可变
1 2 3 4  const char* s2 = &amp;#34;abc&amp;#34;; // const是默认存在的 cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl; // abc s2 = &amp;#34;dfs&amp;#34;; // 改变地址 cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl; // dfs   &amp;ldquo;abc&amp;quot;为字符串常量，s2为常量指针，指向地址可变，但指向的地址的值不能变
以上两者皆可用于函数传值
1 2 3 4 5 6  void print_str(const char * str) { printf(&amp;#34;%s\n&amp;#34;, str); } print_str(s1); // adc print_str(s2); // dfs   关于string和char[],char*的关系  string是类，string是对一个字符串的引用值  1 2 3 4 5 6 7  const char* s1 = &amp;#34;abc&amp;#34;; string s = s1; cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; // abc s += &amp;#34;a&amp;#34;; cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; // abca cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // abc 证明string只是引用了s1    string引用字符串示例  1 2 3 4 5 6 7  const char *s1 = &amp;#34;123&amp;#34;; string str1 = s1; // 若要这样赋值s1必须加const cout &amp;lt;&amp;lt; str1 &amp;lt;&amp;lt; endl; // 123  char s2[] = &amp;#34;234&amp;#34;; string str2 = s2; cout &amp;lt;&amp;lt; str2 &amp;lt;&amp;lt; endl; // 234    string转char*  1 2 3  const char* s1_1 = str1.</description>
    </item>
    
    <item>
      <title>Linux实用操作之文本操作</title>
      <link>/posts/2021/12/text-operation-of-linux-practical-operation/</link>
      <pubDate>Sun, 05 Dec 2021 00:20:09 +0800</pubDate>
      
      <guid>/posts/2021/12/text-operation-of-linux-practical-operation/</guid>
      <description>使用grep抓取期望的结果 在过去登录主机的人中截取登录信息含root的行信息
1  last | grep &amp;#39;root&amp;#39;   比较重要，记忆：
grep [-acinv] [&amp;ndash;color=auto] &amp;lsquo;搜寻字串&amp;rsquo; filename
选项与参数：
-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 &amp;lsquo;搜寻字串&amp;rsquo; 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 &amp;lsquo;搜寻字串&amp;rsquo; 内容的那一行
&amp;ndash;color=auto ：可以将找到的关键字部分加上颜色的显示喔
awk命令操作文本  格式化输出：以tab隔开打印前五行中每行的第一和第三个字符  awk &amp;lsquo;{[pattern] action}&amp;rsquo; {filenames}
1  last -n 5 | awk &amp;#39;{print $1 &amp;#34;\t&amp;#34; $3}&amp;#39;   注意必须是内双引号外单引号的形式。
 分隔字符  awk -F #-F指定所操作文件中的目标分割字符
使用&amp;quot;,&amp;ldquo;分隔
1  awk -F, &amp;#39;{print $1 &amp;#34; - &amp;#34; $2}&amp;#39; log.</description>
    </item>
    
    <item>
      <title>Java重写equals方法的同时为什么要重写hashcode方法</title>
      <link>/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</link>
      <pubDate>Fri, 26 Nov 2021 09:23:27 +0800</pubDate>
      
      <guid>/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</guid>
      <description>提出问题 先看一个例子：
当两个人年龄相同时，我们认为这两个对象相同：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Person { private int age; private String name; public Person(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return &amp;#34;Person{&amp;#34; + &amp;#34;age=&amp;#34; + age + &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() !</description>
    </item>
    
    <item>
      <title>Java中通过反射获取带参数类型的方法</title>
      <link>/posts/2021/11/get-methods-with-parameter-types-through-reflection-in-java/</link>
      <pubDate>Wed, 17 Nov 2021 23:30:04 +0800</pubDate>
      
      <guid>/posts/2021/11/get-methods-with-parameter-types-through-reflection-in-java/</guid>
      <description>问题的提出 在后端与前端进行数据传送时，需要先把数据进行类型转换，从前端获得的字符串类型（由json类型数据转化而成），转换成一个Java类。通过了解，发现可以采用导入Gson包的方式调用方法实现这个功能：
1 2 3 4  Person p = new Person(1, &amp;#34;jzh&amp;#34;); Gson gson = new Gson(); String p_json = gson.toJson(p); Person p1 = gson.fromJson(p_json, Person.class);   从中可见gson.fromJson的第二个参数就是一个类对象，针对于无参的类可以直接通过.class获取类对象，然而有参怎么办呢？如下：
1 2 3 4 5 6 7  ArrayList&amp;lt;Person&amp;gt; people = new ArrayList&amp;lt;&amp;gt;(); people.add(new Person(1, &amp;#34;jzh&amp;#34;)); people.add(new Person(2, &amp;#34;zh&amp;#34;)); people.add(new Person(3, &amp;#34;z&amp;#34;)); String ps_json = gson.toJson(people); ArrayList&amp;lt;Person&amp;gt; people1 = gson.fromJson(ps_json,new TypeToken&amp;lt;ArrayList&amp;lt;Person&amp;gt;&amp;gt;() { }.getType());   这里通过创建匿名内部类的方式实现了转换，也可以通过创建类继承于TypeToken实现。
1 2 3  class MyType extends TypeToken&amp;lt;ArrayList&amp;lt;Person&amp;gt;&amp;gt; {} ArrayList&amp;lt;Person&amp;gt; people1 = gson.</description>
    </item>
    
    <item>
      <title>Linux上部署JAR包项目后的文件上传问题</title>
      <link>/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/</link>
      <pubDate>Wed, 03 Nov 2021 00:38:12 +0800</pubDate>
      
      <guid>/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/</guid>
      <description>在进行上传文件时，一般会先获取项目类路径：
1 2  File relativePathFile = new File(URLDecoder.decode(ResourceUtils.getURL(&amp;#34;classpath:&amp;#34;).getPath(), &amp;#34;utf-8&amp;#34;)); String absolutePath = relativePathFile.getAbsoluteFile().getPath();   首先取得相对路径，再进一步取得绝对路径，结果如下：
 如果单纯运行一个java项目：  获得路径为：
${project}/target/classes
 如果是运行jar包，且是在Linux系统上，则获得路径大致为：  .../${jar包名}!/BOOT-INF/classes! [centos7.9下]
所以如果是jar包启动并上传文件，则无法正确放到类路径下。
所以需指定新的上传路径。
在如下路径中：
1 2  [root@VM-0-11-centos app]# ls application.yaml LonersHub-0.0.1-SNAPSHOT.jar static   假设我要把文件上传到和jar包同一路径下的static内, 可以在jar包同一路径下新建并编辑application.yaml文件如下：
1 2 3 4 5  spring: resources: static-locations: - classpath:static/ - file:/app/static/   然后在文件上传是指定上传路径即可。
这里编写一个工具类如下：
关注getUploadPath方法，它用于获取上传路径。
首先，为了方便后期维护和部署使用，我们先判断项目运行所在的操作系统，如果是生产环境linux则上传到上面指定的目录，而如果是本地测试项目，则将其上传到类路径下的默认位置即可。
比如，要上传一个头像：
 linux下：  返回/app/static/${uploadType}/${fileName}
e.g. /app/static/avatar/test.jpg
 window下：  返回 ${project}/target/classes/static/${uploadType}/${fileName}</description>
    </item>
    
    <item>
      <title>Linux主机部署springboot项目全过程</title>
      <link>/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/</link>
      <pubDate>Wed, 03 Nov 2021 00:30:25 +0800</pubDate>
      
      <guid>/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/</guid>
      <description>注：部署环境为centos7.9版本
操作步骤如下：
 配置Java环境 配置mysql环境 配置redis环境 生成，上传并运行JAR包项目  配置Java环境 前往：Linux配置Java环境
配置mysql环境   配置mysql环境，前往：Linux配置Mysql环境
  建立数据库并新建表，可通过sql脚本快速建成。
  配置redis环境  安装redis：yum install redis 启动redis：systemctl start redis 默认启动在了6379端口，如需特殊指定可在/etc/redis.conf中修改默认配置 设置开机自启动redis：systemctl enable redis  生成，上传并运行JAR包项目 上传JAR包项目 1 2  mvn clean mvn package   即可把项目打包为JAR包，再通过WINSP上传到服务器。
先新建一个app文件夹，放置项目所有内容：
1 2  mkdir /app chmod 777 /app   新建并编辑application配置文件 由于主机上的mysql密码与本地mysql密码不同，所以在JAR包同一个文件目录下新建application配置文件并指定新的密码，允许JAR项目时该application配置文件优先级是更高的。这里我还指定了用于linux下文件读取上传的目录路径。
1 2 3 4 5 6 7  spring: datasource: password: ...... resources: static-locations: - classpath:static/ - file:/app/static/   1 2 3  [root@VM-0-11-centos app]# chmod -R 777 * [root@VM-0-11-centos app]# ls application.</description>
    </item>
    
    <item>
      <title>Linux配置Java环境</title>
      <link>/posts/2021/07/configuring-java-environment-for-linux/</link>
      <pubDate>Fri, 23 Jul 2021 20:49:56 +0800</pubDate>
      
      <guid>/posts/2021/07/configuring-java-environment-for-linux/</guid>
      <description>速通  ubuntu: /etc/bash.bashrc centos: /etc/bashrc  1 2 3 4 5 6 7 8 9 10  # jdk8.sh # 安装jdk-8u311-linux-x64并配好环境变量的脚本 tar -zxvf jdk-8u311-linux-x64.tar.gz mkdir /usr/local/java mv ./jdk1.8.0_311 /usr/local/java echo &amp;#39;# java env&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export JAVA_HOME=/usr/local/java/jdk1.8.0_311&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export PATH=$JAVA_HOME/bin:$PATH&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc source /etc/bash.bashrc   下文是分步解释。
获取JDK 首先下载jdk压缩包，然后解压缩jdk压缩包：
1 2 3 4 5 6  [root@VM-0-11-centos ~]# ls bin jdk-8u311-linux-x64.tar.gz passwd var [root@VM-0-11-centos ~]# tar -zxvf jdk-8u311-linux-x64.</description>
    </item>
    
    <item>
      <title>Docker简单使用过程记录</title>
      <link>/posts/2021/05/docker-simple-use-process-record/</link>
      <pubDate>Wed, 19 May 2021 22:52:52 +0800</pubDate>
      
      <guid>/posts/2021/05/docker-simple-use-process-record/</guid>
      <description>开启docker服务 1 2  [root@VM-0-11-centos ~]# curl -sSL https://get.daocloud.io/docker | sh [root@VM-0-11-centos ~]# systemctl start docker   测试docker 一、下载ubuntu镜像
1 2 3 4 5 6 7 8 9 10 11 12  [root@VM-0-11-centos ~]# docker run ubuntu:15.10 /bin/echo &amp;#34;hello world&amp;#34; Unable to find image &amp;#39;ubuntu:15.10&amp;#39; locally 15.10: Pulling from library/ubuntu 7dcf5a444392: Pull complete 759aa75f3cee: Pull complete 3fa871dc8a2b: Pull complete 224c42ae46e7: Pull complete Digest: sha256:02521a2d079595241c6793b2044f02eecf294034f31d6e235ac4b2b54ffc41f3 Status: Downloaded newer image for ubuntu:15.</description>
    </item>
    
    <item>
      <title>Synchronized到底锁了谁</title>
      <link>/posts/2021/05/who-the-hell-is-synchronized-locking/</link>
      <pubDate>Wed, 19 May 2021 22:43:45 +0800</pubDate>
      
      <guid>/posts/2021/05/who-the-hell-is-synchronized-locking/</guid>
      <description>Synchronized方法   静态方法上的锁
静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个类。
  普通方法上的锁
实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。在实例方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个对象实例。
  Synchronized代码块  synchronized(this){...}  this关键字所代表的意思是该对象实例，这种用法synchronized锁住的是对象实例。
 synchronized(Demo.class){...}  锁的是该类。
 synchronized(obj){...}  synchronized同步代码块对对象内部的实例加锁。
假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，均能获取各自的锁。
代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class Demo { private Object lock1 = new Object(); private Object lock2 = new Object(); public void demo1() { synchronized (lock1) { while (true) { //死循环目的是为了让线程一直持有该锁  System.</description>
    </item>
    
    <item>
      <title>Git实用操作之解决冲突</title>
      <link>/posts/2021/05/conflict-resolution-of-git-practical-operation/</link>
      <pubDate>Wed, 19 May 2021 22:12:54 +0800</pubDate>
      
      <guid>/posts/2021/05/conflict-resolution-of-git-practical-operation/</guid>
      <description>首先提交当前分支修改：
1 2  git add . git commit -m &amp;#34;msg&amp;#34;   这时如果其他分支对当前提交分支进行了修改，直接push上去则会失败并提醒进行冲突的解决。
因此，进行pull，将更改拉取下来进行冲突的解决。
1  git pull   这时有2种可能的情况，要么其他分支的修改地方和自己的修改的地方不冲突，要么冲突。
如果不冲突且接受其他分支的容易修改，则可以直接push上去了。
如果冲突了，则对所有冲突的地方merge，即在提示冲突的地方进行修改的选择即可。
1 2 3 4 5  &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD hello world ======= hello kitty &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; another-branch   HEAD标记&amp;quot;Current Change&amp;quot;，即当前分支的修改，&amp;ldquo;another-branch&amp;quot;标记其他分支的修改，两者之间用&amp;rdquo;===&amp;ldquo;隔开。
修改完成后，重新进行完整的提交即可：
1 2 3  git add . git commit -m &amp;#34;msg&amp;#34; git push   over.</description>
    </item>
    
    <item>
      <title>Java与C&#43;&#43;中的值传递和引用传递解析</title>
      <link>/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</link>
      <pubDate>Sat, 01 May 2021 20:16:39 +0800</pubDate>
      
      <guid>/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</guid>
      <description>先说结论：Java只有值传递，而C++既有值传递又有引用传递。
Java的参数传递 先定义3个方法如下：
1 2 3 4 5 6 7 8 9 10 11  public static void change1(String str, int num) { str = &amp;#34;world&amp;#34;; // 这里就相当与新new了一个对象!  num = 100; } public static void change2(User user) { user.age = 1; user.name = &amp;#34;mary&amp;#34;; } public static void change3(User user) { user = new User(1, &amp;#34;mary&amp;#34;); }   进行测试：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void main(String[] args) { String str = &amp;#34;hello&amp;#34;; int num = 1; System.</description>
    </item>
    
    <item>
      <title>Window实用命令记录之文件操作</title>
      <link>/posts/2021/04/file-operation-recorded-by-window-utility-command/</link>
      <pubDate>Mon, 19 Apr 2021 13:48:19 +0800</pubDate>
      
      <guid>/posts/2021/04/file-operation-recorded-by-window-utility-command/</guid>
      <description>创建文件或文件夹 cmd下创建文件 1  type nul &amp;gt; test.jpg   powershell下创建文件 1  new-item test.jpg   创建文件夹 1  mkdir test   重命名文件 注意不能指定到新的路径。
1  PS D:\a\tmp\test&amp;gt; ren test.txt my.txt   移动文件 该命令也可用于重命名。
1  PS D:\a\tmp\test&amp;gt; move test.jpg mydir   复制文件和文件夹 copy无法递归复制，而xcopy可以。
1  PS D:\a\tmp\test\mydir&amp;gt; copy test.jpg test1.jpg   1 2 3 4 5 6 7 8 9 10 11 12  # mydir not empty PS D:\a\tmp\test&amp;gt; copy mydir mydir1 PS D:\a\tmp\test&amp;gt; ls mydir1 # empty PS D:\a\tmp\test&amp;gt; xcopy mydir mydir2 目标 mydir2 是文件名 还是目录名 (F = 文件，D = 目录)?</description>
    </item>
    
    <item>
      <title>Linux实用操作之shell变量运算</title>
      <link>/posts/2021/04/shell-variable-operation-of-linux-practical-operation/</link>
      <pubDate>Mon, 12 Apr 2021 23:21:41 +0800</pubDate>
      
      <guid>/posts/2021/04/shell-variable-operation-of-linux-practical-operation/</guid>
      <description>算术运算 1 2 3 4 5 6 7 8 9  [root@VM-0-11-centos ~]# a=1 [root@VM-0-11-centos ~]# echo $a 1 [root@VM-0-11-centos ~]# b=$((a*12)) [root@VM-0-11-centos ~]# echo $b 12 [root@VM-0-11-centos ~]# b=$((b+b)) [root@VM-0-11-centos ~]# echo $b 24   比较运算 指令：-eq -ne -lt -gt -ge -le
1 2 3 4 5  a=10 [root@VM-0-11-centos ~]# [ $a -eq 10 ] &amp;amp;&amp;amp; echo yes yes [root@VM-0-11-centos ~]# [ $a -ge 11 ] &amp;amp;&amp;amp; echo yes || echo no no   指令：-a -o</description>
    </item>
    
    <item>
      <title>Linux实用操作之编辑命令与变量</title>
      <link>/posts/2021/04/editing-commands-and-variables-of-linux-practical-operation/</link>
      <pubDate>Mon, 05 Apr 2021 23:01:48 +0800</pubDate>
      
      <guid>/posts/2021/04/editing-commands-and-variables-of-linux-practical-operation/</guid>
      <description>配置环境变量（以Java为例） Linux相关配置文件解析  bashrc部分:   /etc/bashrc: 针对所有用户，每开启一个shell都会执行一次 /etc/skel/.bashrc: 针对所有用户，用于在新建一个用户时默认给用户配置的bashrc ~/.bashrc: 只针对单个用户，每开启一个shell执行一次  profile部分:   /etc/profile: 针对所有用户，首次登录执行一次 /etc/skel/bash_profile: 针对所有用户，用于在新建一个用户时默认给用户配置的bashr_profile ~/.bash_profile: 只针对单个用户，首次登录执行一次  编辑/etc/bashrc文件 也可以选择编辑/etc/profile。
1 2 3 4 5 6 7 8  [root@VM-0-11-centos ~]# vim /etc/bashrc # 进行全局配置 进行添加如下： #JAVA export JAVA_HOME=/usr/local/java/jdk1.8.0_311 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar    使配置文件生效：  1  source /etc/bashrc   验证Java环境： 1 2 3 4 5 6 7 8 9  [root@VM-0-11-centos ~]# java -version java version &amp;#34;1.</description>
    </item>
    
    <item>
      <title>Linux实用操作之文件操作</title>
      <link>/posts/2021/04/file-operation-of-linux-practical-operation/</link>
      <pubDate>Mon, 05 Apr 2021 22:38:46 +0800</pubDate>
      
      <guid>/posts/2021/04/file-operation-of-linux-practical-operation/</guid>
      <description>观察文件信息 1 2  drwxr-xr-x 2 root root 4096 Jan 2 18:41 source 文件类型+文件权限+目录或链接个数+创建者+所在组+文件大小+修改日期+名称   关于文件类型：
 d: directory -: file l: link p: pipeline，管道文件 b: block，块设备文件 c: character，字符设备文件 s: socket，套接字文件  文件创建 1 2 3 4 5 6 7 8 9  [root@VM-0-11-centos d3]# touch f1 [root@VM-0-11-centos d3]# ll total 0 -rw-r--r-- 1 root root 0 Apr 10 00:26 f1 # -d 修改创建时间 [root@VM-0-11-centos d3]# touch -d &amp;#34;2022/4/10 00:27&amp;#34; f1 [root@VM-0-11-centos d3]# ll total 0 -rw-r--r-- 1 root root 0 Apr 10 00:27 f1   目录创建 1 2 3 4  [root@VM-0-11-centos test]# mkdir -p d1/d2/d3 [root@VM-0-11-centos test]# cd d1/d2/d3 [root@VM-0-11-centos d3]# pwd # 查看当前路径 /root/test/d1/d2/d3   文件移动 1 2 3 4 5  [root@VM-0-11-centos test]# ls t1.</description>
    </item>
    
    <item>
      <title>Linux实用操作之进程管理</title>
      <link>/posts/2021/03/process-management-of-linux-practical-operation/</link>
      <pubDate>Wed, 31 Mar 2021 22:55:53 +0800</pubDate>
      
      <guid>/posts/2021/03/process-management-of-linux-practical-operation/</guid>
      <description>查看所有进程 ps -ef  -e : all processes (-A) -f : full-format, including command lines  1 2  [root@VM-0-11-centos ~]# ps -ef | head -n 1 UID PID PPID C STIME TTY TIME CMD   解释如下：
 PPID 父进程ID C 占用CPU百分比 STIME 就是&amp;quot;start time&amp;quot; TTY 进程在哪个终端显示 CMD 命令的名称和参数  ps aux  a: all with tty, including other users (和-a是不同的) u: user-oriented format x: processes without controlling ttys  1 2  [root@VM-0-11-centos ~]# ps -aux | head -n 1 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND   解释如下：</description>
    </item>
    
    <item>
      <title>Linux实用操作之工作调度</title>
      <link>/posts/2021/03/job-scheduling-of-linux-practical-operation/</link>
      <pubDate>Wed, 31 Mar 2021 22:34:24 +0800</pubDate>
      
      <guid>/posts/2021/03/job-scheduling-of-linux-practical-operation/</guid>
      <description>at命令 create job 1 2 3 4 5 6 7 8 9 10  [root@VM-0-11-centos ~]# at 22:38 at&amp;gt; echo &amp;#34;hello world&amp;#34; &amp;gt; ~/at-test.txt # ctrl D at&amp;gt; &amp;lt;EOT&amp;gt; job 3 at Thu Mar 31 22:38:00 2022 [root@VM-0-11-centos ~]# at now +2 minute at&amp;gt; echo &amp;#34;hello kitty&amp;#34; &amp;gt;&amp;gt; ~/at-test.txt # ctrl D at&amp;gt; &amp;lt;EOT&amp;gt; job 4 at Thu Mar 31 22:39:00 2022   check job 1 2 3 4 5 6 7 8 9 10 11 12 13 14  [root@VM-0-11-centos ~]# ls at-test.</description>
    </item>
    
    <item>
      <title>Linux实用操作之网络管理</title>
      <link>/posts/2021/01/network-management-of-linux-practical-operation/</link>
      <pubDate>Sun, 03 Jan 2021 00:27:58 +0800</pubDate>
      
      <guid>/posts/2021/01/network-management-of-linux-practical-operation/</guid>
      <description>查看内网IP grep抓取inet行，sed删除inet字串和netmask.*字串
1  alias myip=&amp;#34; ifconfig eth0 | grep &amp;#39;inet &amp;#39; | sed &amp;#39;s/inet//g&amp;#39; | sed &amp;#39;s/netmask.*$//g&amp;#39;&amp;#34;   test:
1 2  [root@VM-0-11-centos ~]# myip 172.17.0.11   查看外网IP 1  curl cip.cc   show:
IP : ${my_ip} 地址 : 中国 中国
数据二 : 上海市 | 腾讯云
数据三 : 中国北京北京 | 腾讯
URL : http://www.cip.cc/${my_ip}
查看IP端口状况 1 2 3 4 5 6  [root@VM-0-11-centos ~]# netstat -ntlp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.</description>
    </item>
    
    <item>
      <title>Linux实用操作之修改默认配置</title>
      <link>/posts/2021/01/modifying-the-default-configuration-of-linux-practical-operation/</link>
      <pubDate>Sun, 03 Jan 2021 00:10:38 +0800</pubDate>
      
      <guid>/posts/2021/01/modifying-the-default-configuration-of-linux-practical-operation/</guid>
      <description>修改vim中tab长度 设置vim中tab长度
1 2 3  vim /etc/vimrc set tabstop=4   修改vim自动缩进长度 1 2 3  vim /etc/vimrc set shiftwidth=4   禁用烦人的蜂鸣声  禁用bash蜂鸣声  1 2 3  vim /etc/inputrc set bell-style none   禁用vim蜂鸣声  1 2 3  vim /etc/vimrc set noeb vb t_vb=   (vb即visual bell用屏幕的闪烁代替响铃 t_vb就是闪烁设置为空，即不表现出闪烁)</description>
    </item>
    
    <item>
      <title>图的着色问题汇总</title>
      <link>/posts/2020/12/summary-of-coloring-problems-of-graphs/</link>
      <pubDate>Sat, 05 Dec 2020 12:34:05 +0800</pubDate>
      
      <guid>/posts/2020/12/summary-of-coloring-problems-of-graphs/</guid>
      <description>二分图问题 能否只用2种颜色对一个图上色，并且使得共边顶点不同色？
代码解决：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  vector&amp;lt;int&amp;gt; G[MAX_V]; int vertexes; int edges; int color[MAX_V]; //二分图，颜色为1或-1 bool dfs(int v, int c) { color[v] = c; for (int i = 0; i &amp;lt; G[v].size(); i++) { if (color[G[v][i]] == c) return false; if (color[G[v][i]] == 0 &amp;amp;&amp;amp; !dfs(G[v][i], -c)) return false; } return true; } void solve() { for (int i = 0; i &amp;lt; vertexes; i++) { if (color[i] == 0) { if (!</description>
    </item>
    
    <item>
      <title>求解有向图和无向图中是否存在环的方法</title>
      <link>/posts/2020/12/a-method-to-solve-whether-there-are-rings-in-directed-graphs-and-undirected-graphs/</link>
      <pubDate>Wed, 02 Dec 2020 23:50:44 +0800</pubDate>
      
      <guid>/posts/2020/12/a-method-to-solve-whether-there-are-rings-in-directed-graphs-and-undirected-graphs/</guid>
      <description>求解无向图中是否存在环 无向图中是否存在环，可以通过DFS来实现。
由于他是无向图，所以每次开始一次新的递归即进入一个新的连通子图，在该次dfs中可以通过判断新纳入的结点是否与所在连通子图中其他已经访问过的结点存在边，如果存在则证明存在环。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  int mat[maxn][maxn], vis[maxn]; int dfs(int v) { vis[v] = 1; for (int i = 0; i &amp;lt; num; i++) if (mat[v][i]) { if (vis[i] || dfs(i)) return 1; // 该连通子图新纳入的结点与原连通子图中的某一结点有边，即产生了环  } return 0; } memset(vis, 0, sizeof(vis)); int flag = 0; // 无环标志 for (int j = 0; j &amp;lt; num; j++) { if (!</description>
    </item>
    
    <item>
      <title>equals方法和==运算符的作用区别</title>
      <link>/posts/2020/11/the-difference-between-the-equals-method-and-the-operator/</link>
      <pubDate>Wed, 25 Nov 2020 00:21:05 +0800</pubDate>
      
      <guid>/posts/2020/11/the-difference-between-the-equals-method-and-the-operator/</guid>
      <description>equals方法与&amp;quot;==&amp;ldquo;的比较与分析 首先提出一个重要的点:
  == 比较时进行地址的比较
  equals 比较时进行值的比较
  1 2 3 4 5 6 7 8 9  String a = &amp;#34;123&amp;#34;; String b = &amp;#34;123&amp;#34;; System.out.println(a.equals(b)); // true System.out.println(a == b); // true  String a1 = new String(&amp;#34;123&amp;#34;); String b1 = new String(&amp;#34;123&amp;#34;); System.out.println(a1.equals(b1)); // true System.out.println(a1 == b1); // false   好像没问题。
然而阅读源码Object类，可以发现对象中默认equals方法进行的是地址的比较
1 2 3  public boolean equals(Object obj) { return (this == obj); }   再阅读源码String类，可以发现String类中重写了equals方法，覆盖掉了Object的equals方法，所以String的equals是值比较！</description>
    </item>
    
    <item>
      <title>Cmd重要且实用的一些命令</title>
      <link>/posts/2020/11/cmd-some-important-and-practical-commands/</link>
      <pubDate>Fri, 20 Nov 2020 18:17:33 +0800</pubDate>
      
      <guid>/posts/2020/11/cmd-some-important-and-practical-commands/</guid>
      <description>写入文件  写入hello字符串（同时新建了a.txt）  1  echo hello &amp;gt; a.txt    追加写入hello字符串  1  echo hello &amp;gt;&amp;gt; a.txt    将a.txt内容追加写入b.txt  1  type a.txt &amp;gt;&amp;gt; b.txt   新建文件  新建空文件a.txt  1  type null &amp;gt; a.txt   换行（分号换行输出） 1  echo hello; echo peter   关于程序编译 test.cpp: 一个含cin输入的程序
编译cpp
1  g++ test.cpp -o test   以1.in作为标准输入，2.out作为标准输出执行test
1  test &amp;lt; 1.</description>
    </item>
    
    <item>
      <title>矩阵快速幂的介绍及其应用</title>
      <link>/posts/2020/11/introduction-and-application-of-matrix-fast-power/</link>
      <pubDate>Wed, 18 Nov 2020 23:47:15 +0800</pubDate>
      
      <guid>/posts/2020/11/introduction-and-application-of-matrix-fast-power/</guid>
      <description>矩阵快速幂介绍 题目描述
给定n×n的矩阵A，求 A^k。
输入格式
第一行两个整数 n,k 接下来n行，每行n个整数，第i行的第j个数表示Aij。
输出格式
输出 A^k
共n行，每行n个数，第i行第j个数表示Aij, 每个元素对 10^9+7取模。
1 &amp;lt;= n &amp;lt;= 100
0 &amp;lt;= k &amp;lt;= 10 ^ 12
|Aij| &amp;lt;= 1000
分析：
本质上就是快速幂运算，只是底数变成了一个矩阵。
快速幂运算板子： 1 2 3 4 5 6 7 8 9 10  typedef long long ll; ll mod_pow(ll x, ll n, ll mod){ ll res = 1; while(n &amp;gt; 0){ if(n &amp;amp; 1 == 1) res = res * x % mod; // 如果指数是奇数则乘上底数 	x = x * x % mod; // 底数平方 	n &amp;gt;&amp;gt;= 1; // 指数除二 	}	return res; }   由此易得：</description>
    </item>
    
    <item>
      <title>最短路问题汇总</title>
      <link>/posts/2020/11/summary-of-shortest-path-problems/</link>
      <pubDate>Tue, 17 Nov 2020 17:55:32 +0800</pubDate>
      
      <guid>/posts/2020/11/summary-of-shortest-path-problems/</guid>
      <description>注意，这里为了方便描述算法，所以都用了最易理解的邻接矩阵来写，比赛中为了追求效率，一般将邻接矩阵改为链式前向星或者邻接表。
迪杰斯特拉算法 O(V^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  const int MAXN = 100; const int INF = 0x3f3f3f3f; // 有向无环图 DAG int V, E; // 顶点数和边数 int graph[MAXN][MAXN]; // DAG邻接矩阵，初始值为INF，不可达为INF，否则为cost值 int d[MAXN]; // 从某点s出发到其它任意结点的最短路径长度，初始值为INF int visited[MAXN]; // 某点是否访问过，访问过则为1否则为0  // 初始化图 void init() { memset(graph, 0x3f, sizeof(graph)); cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E; int from, to, cost; for (int i = 0 ; i &amp;lt; E; i++) { cin &amp;gt;&amp;gt; from &amp;gt;&amp;gt; to &amp;gt;&amp;gt; cost; graph[from][to] = cost; } } // 迪杰斯特拉算法求解最短路，针对点展开 void Dijkstra(int s) { memset(d, 0x3f, sizeof(d)); memset(visited, 0, sizeof(visited)); visited[s] = 1; for(int i = 0; i &amp;lt; V; i++) d[i] = graph[s][i]; d[s] = 0; int k, min_cost; // 无负边时最多更新n-1(其他结点数)次 	for(int i = 0; i &amp;lt; V - 1; i++){ min_cost = INF; // 寻找最未被访问的且权值最小的路径，需要优化的地方 	for(int j = 0; j &amp;lt; V; j++){ if(!</description>
    </item>
    
    <item>
      <title>关于辗转相除法和扩展欧几里得算法</title>
      <link>/posts/2020/07/on-rolling-division-and-extended-euclidean-algorithm/</link>
      <pubDate>Tue, 21 Jul 2020 20:48:53 +0800</pubDate>
      
      <guid>/posts/2020/07/on-rolling-division-and-extended-euclidean-algorithm/</guid>
      <description>gcd辗转相除法求最大公约数 思路：反复交换取余，直到小的数为0。
1 2 3 4  int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b); }   exgcd扩展欧几里得算法 先介绍贝祖定理：
若a,b为整数，则一定存在整数x,y，使得$ax + by = gcd(a,b)$。
即若$ax + by = m$有解，则m一定为gcd(a,b)的若干倍。
下面是一道题：
有a, -a, b, -b四个整数，各用几次可以使得$ax + by = 1$?
由上述思想则可知gcd(a,b)等于1，可编写一个返回值为gcd(a,b)同时递归计算x和y的函数。
关于求出x和y推导过程：
由$ax + by = gcd(a,b)$ (1)
通过辗转相除法的思想得：$bx_1 + (a \mod b) y_1 = gcd(a,b)$
由$a \mod b = a - (a \div b) \times b$带入得:</description>
    </item>
    
    <item>
      <title>有关素数的一些算法</title>
      <link>/posts/2020/07/some-algorithms-about-prime-numbers/</link>
      <pubDate>Tue, 21 Jul 2020 20:43:04 +0800</pubDate>
      
      <guid>/posts/2020/07/some-algorithms-about-prime-numbers/</guid>
      <description>埃氏筛法 问1000000000000以内有多少个素数？
运用朴素算法必TLE，这时考虑埃氏筛法。
算法思路：
 建立is_prime[]数组，初始化为true； 从2开始筛取，(注意从2开始很重要，因为2为素数，否则需要改变相应后续操作)，若为true，则继续判断是否为素数，若为素数，则将所有该素数的倍数置为false。  相应代码：
1 2 3 4 5 6 7 8 9 10 11 12 13  bool is_prime[MAXN]; //返回n以内的素数个数 int sieve(int n) { int c = 0; for (int i = 2; i &amp;lt;= n; ++i) is_prime[i] = true; for (int i = 2; i &amp;lt;= n; ++i) if (is_prime[i]) { c++; for (int j = 2 * i; j &amp;lt;= n; j += i) is_prime[j] = false; } return c; }   区间筛法 问[21479862, 21499877)之间有多少个素数？</description>
    </item>
    
    <item>
      <title>Python自动爬取花瓣网任意面板中所有图片</title>
      <link>/posts/2020/02/python-automatically-crawls-all-pictures-in-any-panel-of-petal-net/</link>
      <pubDate>Thu, 13 Feb 2020 00:14:23 +0800</pubDate>
      
      <guid>/posts/2020/02/python-automatically-crawls-all-pictures-in-any-panel-of-petal-net/</guid>
      <description>注：该项目只适用于旧版花瓣，但其中的思路值得领会。对于新版花瓣编写的代码，逻辑差别不大。
需要安装的库  urllib easygui selenium webdriver_manager  获取过程  进入面板内 复制当前面板url 启动该脚本按提示进行即可  代码编写流程 分析pin图特点 查看面板源码，可以在对应的script中找到面板中图片的json数据。
在app.page[&amp;ldquo;board&amp;rdquo;]下可以找到&amp;quot;pins&amp;quot;:[{&amp;hellip;}]，主要图片ID(pin)位于这里面。
获取到图片的ID(pin)之后可以对应访问点击图片后进入的地址http://huaban.com/pins/pinId/，并获取页面源码：
显然可见主要图片的源码特征，书写对应正则表达式可以获取图片真实地址。
分析滚动特点 通过滚动页面我们可以发现加载规律：
原来的图片对应的代码：
经过滚动，原来的代码逐渐被一些新的代码取代：
而不难发现他们都有对应的data-id!而data-id就是图片地址中对应的pin。
所以我们可以通过webdriver滚动加载页面，每滚动一次就进行一次data-id的读取，并利用集合进行去重即可。
具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  # 花瓣用户任意面板图片爬取 import urllib.</description>
    </item>
    
    <item>
      <title>Matlab基本用法整理</title>
      <link>/posts/2020/02/basic-usage-sorting-of-matlab/</link>
      <pubDate>Thu, 06 Feb 2020 20:41:12 +0800</pubDate>
      
      <guid>/posts/2020/02/basic-usage-sorting-of-matlab/</guid>
      <description>基本语法方面 提取矩阵某行或某列 1  A(:, [2 3]) 返回第2和第3列   获取随机数 1  randi(100); % 1 到 100 之间的随机整数   初始化数组 1  zeros(1, 30); % 1行30列的全0数组   控制语句 1 2 3 4 5 6 7 8 9 10  for i = 0 : 100 for j = 1 : 10 if (...)  ... else ... end end ... end   格式化输出 1  fprintf(&amp;#34;若选手选择改变，则成功次数为：%d, 成功率为：%f\n&amp;#34;, count, count / SUM);   初等数学方面 求解方程组 注：solve已经改版，不可传入字符串</description>
    </item>
    
  </channel>
</rss>
