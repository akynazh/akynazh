<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Norwegian Wood</title>
    <link>/posts/</link>
    <description>Recent content in Posts on Norwegian Wood</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Jzh</copyright>
    <lastBuildDate>Fri, 29 Jul 2022 18:26:44 +0800</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Zipkin使用记录</title>
      <link>/posts/2022/07/zipkin-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 18:26:44 +0800</pubDate>
      
      <guid>/posts/2022/07/zipkin-usage-record/</guid>
      <description>Zipkin的作用  查看微服务调用过程； 分析微服务依赖关系； 方便地找到调用过程错误发生位置。  Zipkin使用记录 一、下载Zipkin并运行：
1  java -jar zipkin.jar   这样成功运行后，默认在端口9411可以查看图形管理界面。
二、依赖引入
在所有调用到的微服务中引入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   三、配置文件
1 2 3 4 5 6  spring: zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 # 采样率介于0和1之间，1表示全部采集   测试 通过service-name标签搜索自己的微服务名称，即可检索到与该微服务有依赖的所有微服务，可查看调用过程，依赖关系等。
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>SpringCloud-Stream使用记录</title>
      <link>/posts/2022/07/springcloud-stream-usage-record/</link>
      <pubDate>Fri, 29 Jul 2022 17:26:05 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-stream-usage-record/</guid>
      <description>为何使用Stream？ 实现消息的收发可以用许多种方式来实现，如Kafka，RabbitMQ等，而通过Stream可以方便地通过一个Binder对象与这些不同的实现工具对接，应用程序通过Inputs和Outputs来与Binder交互即可实现消息的收发，这样我们就只需要知道如何与Stream交互即可方便地使用消息驱动。
下图即Stream工作原理：
Stream使用记录 一、依赖导入 除去一些基本依赖之外，发布端和订阅端均导入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-stream-rabbit&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、基本配置 发布端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: output: destination: myExchange content-type: application/json binder: defaultRabbit   订阅端：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  spring: cloud: stream: binders: defaultRabbit: type: rabbit environment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: input: destination: myExchange content-type: application/json binder: defaultRabbit group: jzh1   注意，两个订阅端如果实现同一微服务，group应该一样，这样，在同一个组内会发生竞争关系，只有其中一个可以消费（默认采用轮询的机制处理），避免了出现重复消费的问题。</description>
    </item>
    
    <item>
      <title>Config结合Bus使用记录</title>
      <link>/posts/2022/07/config-combined-with-bus-usage-record/</link>
      <pubDate>Wed, 27 Jul 2022 22:00:55 +0800</pubDate>
      
      <guid>/posts/2022/07/config-combined-with-bus-usage-record/</guid>
      <description>为何要使用Config和Bus Config可以进行多个微服务下的全局配置，更加方便，易于管理。
当全局配置修改时，需要通知各个微服务，一个一个地通知是非常耗时的，如果可以通过广播的方式快速将消息传递出去就轻松多了，而通过Bus即可实现这一点。
测试方法 一、在6996端口通过git拉取全局配置，相当于一个ConfigServer，6886和6776端口作为ConfigClient；
二、Bus结合RabbitMQ实现，修改配置时，只通知ConfigServer，达到消息广播的效果。
依赖引入 一、ConfigServer端：
1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、ConfigClient端：
1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   其他一些基本包就省略了。
文件配置 一、ConfigServer端：
以下为application.yml:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  spring: cloud: config: server: git: # github项目地址 uri: https://github.</description>
    </item>
    
    <item>
      <title>SpringCloud-Gateway使用记录</title>
      <link>/posts/2022/07/springcloud-gateway-usage-record/</link>
      <pubDate>Tue, 26 Jul 2022 18:33:44 +0800</pubDate>
      
      <guid>/posts/2022/07/springcloud-gateway-usage-record/</guid>
      <description>网关的作用 如图所示，网关介于外部请求和具体微服务之间，在不暴露内部微服务端口的情况下，通过一个或者多个指定的网关端口统一地处理外部各种请求。
使用SpringCloud Gateway 依赖引入 除了基本依赖以外，引入下列依赖：
1 2 3 4 5 6 7 8 9  &amp;lt;!-- others --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   注意不能引入web相关依赖，因为Gateway是基于WebFlux的。
文件配置 列出部分重要配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14  server: port: 9669 cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: path_route uri: lb://CLOUD-PAYMENT-SERVICE # lb：负载均衡 predicates: - Path=/payment/** - After=2022-07-26T17:33:52.</description>
    </item>
    
    <item>
      <title>Hystrix实现服务熔断与监控</title>
      <link>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</link>
      <pubDate>Tue, 26 Jul 2022 11:39:11 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-realizes-service-fusing-and-monitoring/</guid>
      <description>什么是服务熔断 概念 应对微服务雪崩效应的一种链路保护机制，类似保险丝。
关于雪崩效应 微服务之间的数据交互是通过远程调用来完成的。服务A调用服务，服务B调用服务C，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应。
实现机制 当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。
通过Hystrix实现服务熔断，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，就会启动熔断机制，断路器打开。而在一段时间之后，断路器会变为半开状态，此时允许部分微服务调用，如果都成功了，即不超过设定好的阈值，那么断路器将恢复为关闭状态。
如下图所示：（来自Martin Fowler大神的博客）
应用场景 微服务架构中，多个微服务相互调用出使用
Hystrix实现服务熔断 环境搭建 1. 关于pom.xml 1 2 3 4 5 6 7 8  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   2. 启动类添加@EnableHystrix注解，表示使用熔断器。 实现服务熔断 1. PaymentService.java 1 2 3 4  public interface PaymentService { ... String circuitBreaker(Integer id); }   2. PaymentServiceImpl.java 设置服务熔断的核心配置：
（1）启用断路器:
1  @HystrixProperty(name = &amp;#34;circuitBreaker.enabled&amp;#34;, value = &amp;#34;true&amp;#34;)   （2）设置请求次数:</description>
    </item>
    
    <item>
      <title>Hystrix实现服务降级</title>
      <link>/posts/2022/07/hytrix-enables-service-degradation/</link>
      <pubDate>Tue, 26 Jul 2022 10:59:08 +0800</pubDate>
      
      <guid>/posts/2022/07/hytrix-enables-service-degradation/</guid>
      <description>什么是服务降级 概念 一般指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面有策略的不处理或者用一种简单的方式进行处理，从而释放服务器资源的资源以保证核心业务的正常高效运行。
应用场景 多用于微服务架构中，一般当整个微服务架构整体的负载超出了预设的上限阈值（和服务器的配置性能有关系），或者即将到来的流量预计会超过预设的阈值时。
大致实现过程 为了预防某些功能出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。
使用Hystrix实现服务降级 本实验配合了Feign实现，利用Feign通过接口的方式解耦服务这一特点，通过在实现服务接口的类来编写方法对应的fallback方法。
环境搭建 一、关于pom
在消费方实现服务降级，除了基本包导入外，导入以下：
1 2 3 4 5 6 7 8 9 10 11 12  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、关于application.yml
除了基本配置外，以下两个超时时间的配置需要格外注意：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 设置feign超时时间（默认为1秒） feign: hystrix: enabled: true client: config: default: ConnectTimeOut: 5000 ReadTimeOut: 5000 # 设置hystrix超时时间（默认为1秒） hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000   其他关于Feign的环境配置省略了。</description>
    </item>
    
    <item>
      <title>Linux实用操作之系统服务管理</title>
      <link>/posts/2022/07/system-service-management-of-linux-practical-operation/</link>
      <pubDate>Sun, 24 Jul 2022 20:42:27 +0800</pubDate>
      
      <guid>/posts/2022/07/system-service-management-of-linux-practical-operation/</guid>
      <description>systemctl指令  立即启动一个服务：systemctl start my.service 立即停止一个服务：systemctl stop my.service 重启一个服务：systemctl restart my.service 重新加载一个服务的配置文件：systemctl reload my.service 重载所有修改过的配置文件：systemctl daemon-reload 开启自启动服务：systemctl enable my.service 取消开启自启动：systemctl disable my.service 查看是否已经自启动：systemctl is-enabled my.service 查看服务运行状态：systemctl status my.service 查看所有服务：systemctl --type service  service和chkconfig指令  启动服务：service my.service start 终止服务：service my.service stop 重启服务：service my.service restart 查看服务运行状态：service my.service status 开启或取消开机自启动：chkconfig my.service on/off 查看开机自启动列表：chkconfig --list  Unit配置文件解释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  - Unit - Description，服务的描述 - Requires，定义此unit需在哪个daemon启动后才能够启动 - Service - Type，定义启动时的进程行为。它有以下几种值。 - Type=simple，默认值，执行ExecStart指定的命令，启动主进程 - Type=forking，以 fork 方式从父进程创建子进程，创建后父进程会立即退出 - Type=oneshot，一次性进程，Systemd 会等当前服务退出，再继续往下执行 - Type=dbus，当前服务通过D-Bus启动 - Type=notify，当前服务启动完毕，会通知Systemd，再继续往下执行 - Type=idle，若有其他任务执行完毕，当前服务才会运行 - ExecStart，启动当前服务的命令 - ExecStartPre，启动当前服务之前执行的命令 - ExecStartPost，启动当前服务之后执行的命令 - ExecReload，重启当前服务时执行的命令 - ExecStop，停止当前服务时执行的命令 - ExecStopPost，停止当其服务之后执行的命令 - RestartSec，自动重启当前服务间隔的秒数 - Restart，定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog - TimeoutSec，定义 Systemd 停止当前服务之前等待的秒数 - Environment，指定环境变量 - Install - WantedBy，值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.</description>
    </item>
    
    <item>
      <title>Linux配置Mysql环境</title>
      <link>/posts/2022/07/configuring-mysql-environment-for-linux/</link>
      <pubDate>Sat, 23 Jul 2022 21:27:15 +0800</pubDate>
      
      <guid>/posts/2022/07/configuring-mysql-environment-for-linux/</guid>
      <description>安装mysql yum方式安装mysql 一、获取mysql的rpm包
可从地址：https://dev.mysql.com/downloads/repo/yum/
找到适合自己发行版本的rpm包下载。下面下载的是适用于CentOS7版本的。
1 2 3  [root@VM-0-11-centos ~]# wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm ...... 2022-01-02 12:07:24 (133 KB/s) - ‘mysql80-community-release-el7-3.noarch.rpm’ saved [26024/26024]   二、安装mysql的rpm包
1 2 3 4  [root@VM-0-11-centos ~]# rpm -Uvh mysql80-community-release-el7-3.noarch.rpm ...... Updating / installing... 1:mysql80-community-release-el7-3 ################################# [100%]   这时查看/etc/yum.repos.d即可以看到如下内容：
1 2 3  [root@VM-0-11-centos ~]# ls /etc/yum.repos.d | grep mysql mysql-community.repo mysql-community-source.repo   三、（可选）将mysql80换为mysql57
1 2 3 4 5 6 7 8  [root@VM-0-11-centos ~]# yum-config-manager --disable mysql80-community [root@VM-0-11-centos ~]# yum-config-manager --enable mysql57-community # 查看是否切换成功： [root@VM-0-11-centos ~]# yum repolist enabled | grep mysql mysql-connectors-community/x86_64 MySQL Connectors Community 221 mysql-tools-community/x86_64 MySQL Tools Community 135 mysql57-community/x86_64 MySQL 5.</description>
    </item>
    
    <item>
      <title>Wsl主要操作记录</title>
      <link>/posts/2022/07/wsl-main-operation-records/</link>
      <pubDate>Sat, 23 Jul 2022 17:34:52 +0800</pubDate>
      
      <guid>/posts/2022/07/wsl-main-operation-records/</guid>
      <description>wsl在window开机后自启ssh服务   wsl下创建脚本，执行：vim /etc/init.wsl，并根据需要写入服务：
1  /etc/init.d/${需要的服务} # 或者使用service/systemctl命令   再赋予init.wsl执行权限，执行：chmod +x /etc/init.wsl
  window下在启动目录下创建脚本：wsl.bat，写入开机命令如下：
1  wsl -d &amp;lt;DistributionName&amp;gt; -u root /etc/init.wsl   其中，版本通过wsl -l查看。
  wsl一些常用命令  wsl ~ -u jzh: 以jzh用户登录并进入用户文件夹 wsl --shutdown: 关闭wsl wsl -l -v: 查看已安装的wsl版本 wsl --status: 检查wsl状态 wsl -l --online: 查看可通过在线商店获得的 Linux 发行版列表  wsl修改默认登录用户 &amp;lt;DistributionName&amp;gt; config --default-user root: 将登录默认用户设为root
手动安装wsl的话可能无法生效，可通过修改/etc/wsl.conf完成：
1 2 3  # Set the user when launching a distribution with WSL.</description>
    </item>
    
    <item>
      <title>Wsl自定义安装位置</title>
      <link>/posts/2022/07/wsl-custom-installation-location/</link>
      <pubDate>Sat, 23 Jul 2022 17:27:31 +0800</pubDate>
      
      <guid>/posts/2022/07/wsl-custom-installation-location/</guid>
      <description>自定义wsl安装位置 下载wsl-ubuntu：  20.04版本：https://aka.ms/wslubuntu2004 18.04版本：https://aka.ms/wsl-ubuntu-1804  其他版本自行前往官网查找。
修改后缀名 下载后得到AppxBundle文件，将后缀名改为zip，然后解压。
解压后得到如下内容：
选择x64或ARM64的安装包均可均可，将后缀名改为zip，然后解压。
开始安装wsl-ubuntu 解压后得到如下内容：
双击ubuntu.exe，即可开始安装wsl-ubuntu。
安装完成后在该目录下得到虚拟盘：
注：虚拟盘也可能变成rootfs文件。
登录wsl 安装时会让你指定用户名和密码，这个用户是默认添加到sudoers里的。
如果想用root登录，通过sudo passwd root可以设置root密码（root刚开始没有密码），接着通过su即可登录root。
From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>OpenFeign使用记录</title>
      <link>/posts/2022/07/openfeign-usage-record/</link>
      <pubDate>Fri, 22 Jul 2022 17:39:24 +0800</pubDate>
      
      <guid>/posts/2022/07/openfeign-usage-record/</guid>
      <description>为什么要使用OpenFeign 之前在消费端使用RestTemplate时，每次请求都要进行诸如
1  restTemplate.postForObject(PAYMENT_URL + &amp;#34;/payment/create&amp;#34;, payment, CommonResult.class);   这样的调用，需要指定较多参数，当一个接口调用中需要非常多这样的请求时，会比较繁琐，而且这种方式不够抽象。
OpenFegin利用面向接口编程的思想，抽象化，简化了上述操作。
使用OpenFeign 关于pom.xml 1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   关于application.yml 除了基本配置内容外，注意以下配置：
1 2 3 4 5 6 7 8 9 10 11  feign: # 设置feign客户端超时时间（默认为1秒） client: config: default: ConnectTimeOut: 10000 ReadTimeOut: 10000 # 针对每个接口设置日志监控级别 logging: level: com.jzh.springcloud.service.PaymentService: debug # feign日志以什么级别监控端口   编写服务接口 首先在启动类开启@EnableFeignClients注解，接着编写服务接口：
 添加@FeignClient注解，值为对应微服务名； 方法对应微服务Controller下的方法即可。  1 2 3 4 5 6 7 8 9  @Component @FeignClient(value = &amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;) public interface PaymentService { @GetMapping(&amp;#34;/payment/get/{id}&amp;#34;) CommonResult&amp;lt;Payment&amp;gt; getPaymentById(@PathVariable(&amp;#34;id&amp;#34;) Long id); @PostMapping(&amp;#34;/payment/create&amp;#34;) CommonResult&amp;lt;Integer&amp;gt; createPayment(@RequestBody Payment payment); }   调用接口 注入PaymentController接口，然后即可调用它的方法。</description>
    </item>
    
    <item>
      <title>理解快速幂运算并进行应用</title>
      <link>/posts/2022/07/understand-and-apply-fast-power-operation/</link>
      <pubDate>Thu, 21 Jul 2022 20:44:54 +0800</pubDate>
      
      <guid>/posts/2022/07/understand-and-apply-fast-power-operation/</guid>
      <description>快速幂运算的解释 问n是否满足$x^n \mod n = x (1 &amp;lt; x &amp;lt; n)$？
先由一个例子引入：
$3^{11} = 3 \times 9^5 = 3 \times 9 \times 81^2 = 3 \times 9 \times 6561^1$
$result = 3 \times 9 \times 6561 = 3^{2^0} \times 3^{2^1} \times 3^{2^3}$
可见发现这次运算中，幂的结果等于变化中所有当指数为奇数时底数之积。其中，每次运算均发生指数除二（对应二进制右移一位），且当该指数为奇数时，原式乘上底数。
而这个过程其实相当于一个数进行模2取余求二进制数的过程，每次都除2，当模2余1，即对应二进制最末位为1时乘上底数，则由此可以推知快速幂运算的算法过程。
这个结论是可以证明的，如下：
对于任何十进制正整数n，设其对应二进制数为&amp;quot;$b_m&amp;hellip;b_3b_2b_1$&amp;quot;，则有：
 二进制转十进制：$n = 1b_1+2b_2+4b_3+&amp;hellip;+2^{m-1}b_m$； 幂的二进制展开：$x^n = x^{1b_1}x^{2b_2}x^{4b_3}&amp;hellip;x^{2^{m-1}b_m}$。  则对于$x^n$的求解，可以转化为：
 计算$x^1,x^2,x^4&amp;hellip;x^{m-1}$的值，相当于$x=x^2$的过程； 获取二进制各位$b_1,b_2,b_3,&amp;hellip;,b_m$的值，相当于模2求余的过程。  上述过程中，当$b_i=0$时，$x^{2^{i-1}b_i}=1$，反之为$x^{2^{i-1}}$，由此可以顺利计算$x^n$。
相应代码：
1 2 3 4 5 6 7 8 9 10  typedef long long ll; ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while(n &amp;gt; 0) { if(n &amp;amp; 1 == 1) res = res * x % mod; // 一个数&amp;amp;1的结果就是取该数二进制的最末位 	x = x * x % mod; n &amp;gt;&amp;gt;= 1; }	return res; }   注意，运用位运算可以提高效率！</description>
    </item>
    
    <item>
      <title>Hugo通过Algolia添加站内搜索功能</title>
      <link>/posts/2022/07/hugo-adds-onsite-search-function-through-algolia/</link>
      <pubDate>Wed, 20 Jul 2022 23:46:01 +0800</pubDate>
      
      <guid>/posts/2022/07/hugo-adds-onsite-search-function-through-algolia/</guid>
      <description>注册账号并创建Index 官网链接：Algolia，注册完成后保存好ApiID和ApiKey。
接着，创建一个Index，保存好Index的名称。
数据生成以及上传Algolia 方法一：通过hugo-algolia插件的方式 一、下载hugo-algolia： npm install -g hugo-algolia
二、编写config.yaml
网站根目录下创建config.yaml，编写参数如下：
1 2 3 4 5 6  --- algolia: index: &amp;#34;{indexName}&amp;#34; key: &amp;#34;{key}&amp;#34; appID: &amp;#34;{appID}&amp;#34; ---   三、生成algolia.json
网站根目录下运行： hugo-algolia -s，即可生成 {site}/public/algolia.json，同时该数据也同步到了algolia账户下，可以去官网查看。
四、前往algolia的indices进行搜索类型的设置
可以选择按tag，category，content等内容进行搜索，并指定优先级。
方法二：通过GithubAction的方式 这里不通过插件而是通过hugo定制化地生成algolia.json，然后通过GithubAction在每次push时上传数据。
个人更推荐这样做，更好定制化且方便。同时上面方法一有个bug，对中文数据好像不支持。
一、配置algolia输出文件 1 2 3 4 5 6 7 8 9 10  outputs: home: - HTML - RSS - Algolia outputFormats: Algolia: mediaType: application/json baseName: algolia isPlainText: true   二、生成algolia.</description>
    </item>
    
    <item>
      <title>理解Ribbon并自己实现负载均衡</title>
      <link>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</link>
      <pubDate>Wed, 20 Jul 2022 17:07:35 +0800</pubDate>
      
      <guid>/posts/2022/07/understand-ribbon-and-realize-load-balancing-by-yourself/</guid>
      <description>负载均衡（LB）是什么 对于用户的某个请求，将有多个相同功能的服务点服务该请求，某个服务点挂了，其他服务点还是可以进行服务，这样就实现了系统的高可用。
关于集中式LB和进程内LB 集中式LB 在服务的消费方和提供方之间使用独立的LB设施，（软硬件均可，软件如Nginx，硬件如F5），由该设施负责把访问请求通过某种策略（可自行指定）转发至服务的提供方。
进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务点进行服务。
Ribbon属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它获取服务提供方的地址。
使用Ribbon实现负载均衡 关于导包 1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 已经包含了ribbon --&amp;gt; &amp;lt;/dependency&amp;gt;   注意eureka内置了ribbon。
开启注解 1 2 3 4 5 6 7 8  @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 赋予负载均衡能力  public RestTemplate getRestTemplate() { return new RestTemplate(); } }   访问相同服务名地址即可。
修改Ribbon负载均衡规则 所有规则均实现了IRule接口，通过查看接口实现类即可知道规则的种类。
默认是RoundRobinRule（轮询）这一规则。
下面修改为RandomRule（随机）这一规则：
在启动类扫描不到的包下创建规则： 1 2 3 4 5 6 7  @Configuration public class MyRibbonRule { @Bean public IRule myRule() { return new RandomRule(); } }   在启动类指定规则： 1 2 3 4 5 6 7 8  @SpringBootApplication @EnableEurekaClient @RibbonClient(name=&amp;#34;CLOUD-PAYMENT-SERVICE&amp;#34;, configuration = MyRibbonRule.</description>
    </item>
    
    <item>
      <title>Consul配置过程及测试</title>
      <link>/posts/2022/07/consul-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 16:34:39 +0800</pubDate>
      
      <guid>/posts/2022/07/consul-configuration-process-and-test/</guid>
      <description>前言 类似于zookeeper和eureka，也起到微服务注册中心的作用, 满足分布式系统中的CP原则，是弱可用性的。
不同于zookeeper和eureka这两种主要由Java编写的语言，它主要由Go语言编写。
配置Consul环境  下载consul，配置环境变量。 运行consul agent -dev开启服务。 默认端口为8500，访问localhost:8500进入管理界面。  编写springcloud服务代码 一、关于pom.xml
除了一些基本包的导入之外，关于consul包的导入：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   二、关于application.yml
1 2 3 4 5 6 7 8 9 10  spring: application: name: cloud-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name}   三、启动类添加@EnableDiscoveryClient注解。
consul测试 较为简单，访问localhost:8500查看即可。
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>Zookeeper配置过程与测试</title>
      <link>/posts/2022/07/zookeeper-configuration-process-and-test/</link>
      <pubDate>Tue, 19 Jul 2022 12:00:37 +0800</pubDate>
      
      <guid>/posts/2022/07/zookeeper-configuration-process-and-test/</guid>
      <description>前言 Zookeeper类似于Eureka，起到微服务注册中心的作用，满足分布式系统中的CP原则，是弱可用性的。
配置zookeeper环境 安装zookeeper 下载并解压zookeeper包为zookeeper3.7.1（假设下载的是3.7.1版本）。
然后将zookeeper解压缩到/usr/local/zookeeper3.7.1。
配置参数 一、编辑/conf/zoo.cfg
编辑zookeeper包内配置文件/conf/zoo.cfg（先创建，再将zoo_sample.cfg内容复制到其中）
修改或添加以下内容：
1 2  dataDir=/usr/local/zookeeper3.7.1/dataDir dataLogDir=/usr/local/zookeeper3.7.1/dataLogDir   注意同时创建对应文件夹。其中端口号默认为2181，也可以进行修改。
二、 配置环境变量
1 2 3  # zookeeper export ZOOKEEPER_HOME=/usr/local/zookeeper3.7.1 export PATH=$PATH:$ZOOKEEPER_HOME/bin   接着通过source命令生效。
开启zookeeper连接 （前置条件是已配好java环境）
执行zkServer.sh start即可。
查看连接情况： 1 2 3 4 5 6  zkServer.sh status ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper3.7.1/bin/../conf/zoo.cfg Client port found: 2181. Client address: localhost. Client SSL: false. Mode: standalone   可见已经开启成功了。</description>
    </item>
    
    <item>
      <title>Eureka配置过程与理解</title>
      <link>/posts/2022/07/eureka-configuration-process-and-understanding/</link>
      <pubDate>Sun, 17 Jul 2022 11:39:35 +0800</pubDate>
      
      <guid>/posts/2022/07/eureka-configuration-process-and-understanding/</guid>
      <description>前言 起到微服务注册中心的作用，满足分布式系统中的AP原则，是弱一致性的。
Eureka微服务架构图  服务接口采用集群模式，8001和8002端口都实现支付接口服务。 用户接口在运行在80端口，调用8001和8002的服务。 注册中心内部也采用集群模式，7001和7002端口都实现注册服务。  引入Eureka依赖说明 client端：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   server端：
1 2 3 4  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   7001和7002端口关键配置内容 一、启动类开启注解
1 2 3 4 5 6 7  @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class, args); } }   二、application.yml文件配置
对于7001端口服务：（7002端口类似）
1 2 3 4 5 6 7 8 9 10 11  eureka: instance: hostname: eureka7001.</description>
    </item>
    
    <item>
      <title>《雪国》文摘</title>
      <link>/posts/2022/07/snow-country-abstract/</link>
      <pubDate>Tue, 12 Jul 2022 23:11:48 +0800</pubDate>
      
      <guid>/posts/2022/07/snow-country-abstract/</guid>
      <description>作者：川端康成
黄昏的景色在镜后移动着。也就是说，镜面映现的虚像与镜后的实物在晃动，好像电影里的叠影一样。出场人物和背景没有任何联系。而且人物是一种透明的幻象，景物则是在夜霭中的朦胧暗流，两者消融在一起，描绘出一个超脱人世的象征世界。特别是当山野里的灯火映照在姑娘的脸上时，那种无法形容的美，使岛村的心都几乎为之颤动。  在遥远的山巅上空，还淡淡地残留着晚霞的余晖。透过车窗玻璃看见的景物轮廓，退到远方，却没有消逝，但已经黯然失色。尽管火车继续往前奔驰，在他看来，山野那平凡的姿态显得更加平凡。由于什么东西都不十分惹他注目，他内心反而好像隐隐地存在着一股巨大的感情激流。这自然是由于镜中浮现出姑娘的脸的缘故。只有身影映在窗玻璃上的部分，遮住了窗外的暮景，然而，景色却在姑娘的轮廓周围不断地移动，使人觉得姑娘的脸也像是透明的。是不是真的透明呢？这是一种错觉。因为从姑娘面影后面不停地掠过的暮景，仿佛是从她脸的前面流过。定睛细看，却又扑朔迷离。 车厢里也不太明亮。窗玻璃上的映像，不像真的镜子那样清晰。没有反光。这使岛村看得入了神，他渐渐地忘却了镜子的存在，只觉得姑娘好像漂浮在流逝的暮景之中。 这当儿，姑娘的脸上闪现着灯光。镜中映像的清晰度并没有减弱窗外的灯火。灯火也没有把映像抹去。灯火就这样从她的脸上闪过，但并没有把她的脸照亮。这是一束从远方投来的寒光，模模糊糊地照亮了她眼睛的周围。她的眼睛同灯光重叠的那一瞬间，就像在夕阳的余晖里飞舞的夜光虫，妖艳而美丽。
 岛村明白，自己从一开头就是想找这个女子，可偏偏和平常一样拐弯抹角，不免讨厌起自己来。与此同时，越发觉得这个女子格外的美。从刚才她站在杉树背后喊自己开始，他就感到这个女子的倩影是多么袅娜多姿啊。 玲珑而悬直的鼻梁，虽嫌单薄些，但在下方搭配着的小巧的紧闭的柔唇，却宛如美极了的水蛭环节，光滑而伸缩自如，在默默无言中也有一种动的感觉。如果嘴唇起了皱纹，或者色泽不好，就会显得不洁净。她的嘴唇却不是这样，而是滋润光泽的。两只眼睛，眼梢不翘起也不垂下，简直像有意描直了似的，虽逗人发笑，却恰到好处地镶嵌在两道微微下弯的浓密的短眉毛下。颧骨稍耸的圆脸，轮廓一般，但肤色恰似在白瓷上抹了一层淡淡的胭脂。脖颈底下的肌肉尚未丰满。她虽算不上是个美人，但比谁都要显得洁净。
 岛村朝她望去，突然缩了缩脖子。镜子里白花花闪烁着的原来是雪。在镜中的雪里现出了女子通红的脸颊。这是一种无法形容的纯洁的美。 也许是旭日东升了，镜中的雪愈发耀眼，活像燃烧的火焰。浮现在雪上的女子的头发，也闪烁着紫色的光，更增添了乌亮的色泽。
 玲珑而悬直的鼻梁，虽显得有点单薄，但双颊绯红，很有朝气，仿佛在窃窃私语：我在这里呢。那两片美丽而又红润的嘴唇微微闭上时，上面好像闪烁着红光，显得格外润泽。那樱桃小口纵然随着歌唱而张大，可是很快又合上，可爱极了，就如同她的身体具有的魅力一样。在微弯的眉毛下，那双外眼梢既不翘起，也不垂下，眼睛简直像有意描直了似的，如今滴溜溜的，带着几分稚气。她没有施白粉，都市的艺伎生活却给她留下惨白的肤色，而今天又渗入了山野的色彩，娇嫩得好像新剥开的百合花或是洋葱的球根，连脖颈也微微泛起了淡红，显得格外洁净无瑕。
 火车开动之后，候车室里的玻璃窗豁然明亮起来，驹子的脸在亮光中闪闪浮现，眼看着又消失了。这张脸同早晨雪天映在镜中的那张脸一样，红扑扑的。在岛村看来，这又是介于梦幻与现实之间的另一种颜色。 火车从北面爬上县界的山，穿过长长的隧道，只见冬日下午淡淡的阳光，像被地底下的黑暗吞噬，又像那陈旧的火车把明亮的外壳脱落在隧道里，在重重叠叠的山峦之间，向暮色苍茫的峡谷驶去。山的这一侧还没有下雪。 沿着河流行驶不多久，来到了辽阔的原野，山巅好像精工的雕刻，从那里浮现出一道柔和的斜线，一直延伸到山脚下。山头上罩满了月色。这是原野尽头唯一的景色。淡淡的晚霞把整座山映成深宝蓝色，轮廓分明地浮现出来。月色还很淡，并不使人产生冬夜寒峭的感觉。天空没有一只飞鸟。山麓的原野，一望无垠，远远地向左右伸展，快到河边的地方，耸立着一座好像是水电站的白色建筑物。那是透过车窗望见的、在一片冬日萧瑟的暮色中仅留下来的景物。
 村仿佛坐上了某种非现实的东西，失去了时间和距离的概念，陷入了迷离恍惚之中，徒然地让它载着自己的身躯奔驰。单调的车轮声，开始听的时候像是女子的絮絮话语。 这话语断断续续，而且相当简短，但它却是女子竭力争取生存的象征。他听了十分难过，以致难以忘怀。然而，对渐渐远去的岛村来说，现在这已经是徒增几许旅愁的遥远的声音了。
 “银河，多美啊！” 驹子喃喃自语。她仰望着天空，又跑起来。 啊，银河！岛村也仰头叹了一声，仿佛自己的身体悠然飘上了银河当中。银河的亮光显得很近，像是要把岛村托起来似的。当年漫游各地的芭蕉￼，在波涛汹涌的海上所看见的银河，也许就像这样一条明亮的大河吧。茫茫的银河悬在眼前，仿佛要以它那赤裸裸的身体拥抱夜色苍茫的大地。真是美得令人惊叹。岛村觉得自己那小小的身影，反而从地面上映入了银河。缀满银河的星辰，耀光点点，清晰可见，连一朵朵光亮的云彩，看起来也像粒粒银沙子，明澈极了。而且，银河那无底的深邃，把岛村的视线吸引过去了。</description>
    </item>
    
    <item>
      <title>乐理知识记录</title>
      <link>/posts/2022/07/music-theory-knowledge-record/</link>
      <pubDate>Sun, 10 Jul 2022 14:22:57 +0800</pubDate>
      
      <guid>/posts/2022/07/music-theory-knowledge-record/</guid>
      <description>&amp;hellip;
 From My Blog: akynazh.
Over.</description>
    </item>
    
    <item>
      <title>《菊与刀》文摘</title>
      <link>/posts/2022/07/chrysanthemum-and-knife-abstract/</link>
      <pubDate>Sat, 02 Jul 2022 15:14:43 +0800</pubDate>
      
      <guid>/posts/2022/07/chrysanthemum-and-knife-abstract/</guid>
      <description>作者：本尼迪克特
第5章 背负着历史和社会恩情债的日本人 日本人对于卷入“恩情”的事都表现得十分谨慎。即使是一支烟，递烟的人要是过去与他没有什么交往，也会让他感到别扭。碰到这种情况，日本人表达谢意的最礼貌回答一般是：“真过意不去”（日语是“の毒”，它原本的意思是让人为难的感情）。
曾经有一个日本人给我解释了为什么要这样说：“碰到这样的事，把自己感到为难的情况直接表达出来还会更好受一些，虽然拒绝总是让人难为情。如果轻易接受了这样的帮助，而你又根本没有想过为对方做事，那么你的‘受恩’就是让人感到羞耻的。”因此只能说，“真过意不去”（の毒）。
英语对于“の毒”这句话的翻译，有时是“Thank you”（谢谢。谢谢您的烟）有时是“I am sorry”（很抱歉，很遗憾），或者需要翻译成“I feel like a heel”（蒙您看得起。实在不好意思）。每个译法都没有错误，可是都不贴切。
第8章 名声的价值 他们觉得，如果不能洗刷有关自己的耻辱，那就是彼此之间存在着不公平，“世界就不平衡”。一个正义之士的最高理想就是尽自己最大的努力让世界重归平衡。这是一种高尚的美德，无关于人性中的罪恶。
在欧洲历史上也出现过人们非常看重名誉的时期，人们也把“对名誉的情义”看做一种道德准则，比如文艺复兴时期的意大利，这种风尚也曾盛极一时，还有古典时期西班牙的el valor Espanol（西班牙的勇敢）以及德意志的die Ehre（名誉），都与日本的“对名誉的情义”有很多共通的地方，甚至在一百多年以前欧洲颇为流行的决斗行为似乎也是在与这种道德准则相类似的观念驱使下进行的。
值得注意的是，不管是日本，还是西欧各国，只要是雪耻道德观念成为多数人认同的共同价值，那么这个地方的人多数都会把道德置于物质利益之上。所以，越是为了自己的“名誉”而牺牲财产、家庭及其生命的人，就越被认为是一个有着高尚道德的人。名誉已经成了道德的一部分，它被这个国家常常作为“精神”价值的基础而大大提倡。这种价值观必然会产生对物质价值观的贬抑，同样它能够给这个民族带来与众不同的东西。
这种对于名誉十分看重的观念，正与我们美国人在生活中到处都要激烈竞争和公开对抗的观念有一个鲜明的对比。在美国的一些政治或经济活动中，如果要获得或保持某种物质利益，那一定是一种“战争”。日本人对于名誉的捍卫就像我们对于利益的捍卫一样，没有什么不同。
 不过，我们不要觉得亚洲大陆都会有出现因捍卫自己的名誉而有的敌意和伺机报复甚至是极端行动。这完全不是东方的气质，中国人就不会这样，暹罗人、印度人也没有这个特点。当中国人遇到侮辱或诽谤的时候，他们会认为这些人是“小人”，是没有道德的人。中国人非常重视名誉但中国人不会像日本人一样把名誉看成是高尚的理想。在中国，如果一个人因为名誉受损而使用不正当的暴力来肆意报复所遇的侮辱被视为一种十分愚蠢的行为。他们认为这是神经过敏，十分可笑。他们也不会一定要做什么以证明自己的清白，更多时候，他们会对毫无根据的侮辱和诽谤置之不理，因为在中国人眼里，“君子”是不值得和“小人”一般见识的。至于暹罗人，根本无法从他们身上看到有谁对侮辱多么敏感。他们和中国人一样，让诽谤者自己处于尴尬的地位，便足以保证自己的名誉不会受到损害。他们的格言说：“让对方暴露自己卑鄙的最好办法就是自己的容忍。”
 如果说世界上有最不能饶恕的罪过的话，那就是待人没有诚意，而嘲笑别人是最没有诚意的待人之道。
 如果有人朝我发火，我会原谅他，因为有些人就是有一副急脾气；如果有人对我撒谎，我也可以原谅他，因为有些谎言是被逼无奈的选择；如果有人在传一些没有任何根据的流言或者背后对别人品头论足，我同样可以原谅他，因为当人们在遇到别人聊起闲话时，有时候会不自觉地陷进去。
甚至就算是一个杀人犯，我也不会不分青红皂白彻底否定他。可是对于嘲笑别人的人，这是绝对无法原谅的，因为这样的人内心之中没有任何待人的真诚，所以他才不顾他人的感受让一个无辜者难堪。
现在让我来说明一下我对这两个词的定义。所谓杀人犯，就是残害他人肉体的人；而所谓嘲笑者，是残害他人心灵的人。
 遇到失败、污蔑或者被排斥的日本人都非常敏感，因此常常生自己的气而不是生别人的气。现在的日本小说大多所描写的就是一个有教养的日本人是如何不安地面对极端狂怒与悲伤抑郁的故事，这能反映很多日本人的情绪。在小说中，主角对于一切不满，讨厌日常生活，讨厌家庭，讨厌城市，讨厌乡村。这种情绪不是因为自己的理想没有实现，而是在理想的目标面前，自己的努力太过渺小。其实如果有一个远大的目标远景，无论这是一个多么遥远的目标，日本人的厌倦情绪都会消失得无影无踪，之所以有这种厌倦情绪更多的是因为自己的敏感，他们常常害怕自己被排斥在伟大事业之外，因此内心没有依靠。
 日本的小说所反映的内容总是一个弥漫着能够让人情绪爆发的有毒气体的社会。无论是小说的主人公还是作者本人都不会花心思弄明白为什么在日本社会中会弥漫着这样的空气，似乎这是一种正常现象。正是因为总有这种刺激人们情绪的氛围，所以人们都容易伤感。在封建时代，日本人会把自己的情绪指向对自己进行侵犯的人，可是现在，他们却将这种攻击转向自己。在他们看来，一个人忧郁不一定因为十分明确的原因，虽然能够找一些借口安慰自己：我是因为某事而心情不好，可是他们内心之中更多的是埋怨自己。</description>
    </item>
    
    <item>
      <title>Window添加命令别名的方法</title>
      <link>/posts/2022/06/how-to-add-command-alias-in-window/</link>
      <pubDate>Fri, 24 Jun 2022 22:52:59 +0800</pubDate>
      
      <guid>/posts/2022/06/how-to-add-command-alias-in-window/</guid>
      <description>前言 下面将介绍3种方法：
 CMD添加别名的方法 PowerShell添加别名的方法 通过添加环境变量的方式设置别名  CMD添加别名的方法 设置临时的别名 可以通过doskey命令实现。
1  doskey ls=echo ====== ^&amp;amp;^&amp;amp; dir /b $* ^&amp;amp;^&amp;amp; echo ======   $*表示还可能有其他命令参数，^&amp;amp;^&amp;amp;用于分开多条命令。
单纯在一个cmd窗口中使用doskey设置别名，别名只能在该窗口中使用。
设置永久的别名 可以通过将doskey命令写入bat脚本，再把脚本路径添加到注册表Autorun实现永久且所有cmd都可用的别名，具体步骤如下：
 编写脚本：  1 2 3  @echo off doskey ls=dir /b $* doskey lss=echo ====== ^&amp;amp;^&amp;amp; dir /b $* ^&amp;amp;^&amp;amp; echo ======   添加路径到注册表  在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor下的Autorun中，将数值设为doskey命令脚本所在的路径即可。这样所有用户都可以使用设置好的别名。
也可在HKEY_CURRENT_USER下的对应位置设置，只针对当前用户设置别名。
优缺点 通过doskey的方式，挺方便的，但是在命令非常多的情况下不是很方便，同时，设置的命令还不可以在powershell下运行。
PowerShell添加别名的方法 为PowerShell设置临时的别名 1 2 3  PS C:\Users\akyna&amp;gt; set-alias escc esc PS C:\Users\akyna&amp;gt; escc .</description>
    </item>
    
    <item>
      <title>使用x86_64汇编写一个自旋锁</title>
      <link>/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/</link>
      <pubDate>Thu, 09 Jun 2022 23:37:51 +0800</pubDate>
      
      <guid>/posts/2022/06/use-x86-64-assemble-and-write-a-spin-lock/</guid>
      <description>一、理论分析 自旋锁，顾名思义，即自己不断旋转重复进行的锁，当多个线程访问同一资源时，为实现互斥访问，必须给目标资源加锁，此时只允许一个线程访问，此时其他线程无法访问，并且一直重复请求访问，直到该锁被释放。访问完资源的线程及时释放锁以供其他资源访问。
自旋锁可以通过比较替换算法实现：设锁为1时被占用，为0时空闲。当一个线程请求锁时，即进入请求锁循环“spinlock”，设预期值为0，修改值为1，让锁值与预期值比较，若锁值等于预期值，则锁空闲，将锁值置为修改值，退出spinlock循环；若锁值不等于预期值，则证明锁被占用，继续spinlock循环。
为验证是否成功实现自旋，开启一个释放锁线程，请求锁线程自旋一段时间后，释放锁线程进行锁的释放，即把锁值置为预期值0。此时，请求锁线程成功获得锁并退出spinlock循环。
二、设计与实现 使用x86_64汇编实现自旋锁：
Intel语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // 尝试获取锁 void lock(long *p) { long a = 0, c = 1; printf(&amp;#34;try to get lock...\n&amp;#34;); __asm__( &amp;#34;push rax \n\t&amp;#34; &amp;#34;push rcx \n\t&amp;#34; &amp;#34;spin_lock: \n\t&amp;#34; &amp;#34;mov rcx, %[c] \n\t&amp;#34; &amp;#34;mov rax, %[a] \n\t&amp;#34; // 比较并替换算法，若p==rax==0则获得锁并使p=rcx(==1)，若p(==1)!</description>
    </item>
    
    <item>
      <title>通过Wireshark分析TCP原理</title>
      <link>/posts/2022/06/analyze-tcp-principle-through-wireshark/</link>
      <pubDate>Thu, 09 Jun 2022 23:18:55 +0800</pubDate>
      
      <guid>/posts/2022/06/analyze-tcp-principle-through-wireshark/</guid>
      <description>使用Wireshark作为抓包工具，通过ftp文件上传过程分析tcp原理，主要分析过程包括三次握手建立连接的过程，文件传输的过程，四次挥手断开连接的过程。
设备信息  主机：安装了ftp的window11（ip:172.23.224.1） 虚拟机：安装了vsftpd的wsl2（ubuntu18）(ip:172.23.234.65)  操作与分析过程 打开Wireshark进行捕获  选择**vEthernet(WSL)**连接进行捕获。 使用过滤表达式ip.addr==172.23.234.65&amp;amp;&amp;amp;tcp进行捕获。  通过ftp上传文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14  PS C:\Users\akyna&amp;gt; ftp 172.23.234.65 连接到 172.23.234.65。 220 (vsFTPd 3.0.3) 200 Always in UTF8 mode. 用户(172.23.234.65:(none)): akyna 331 Please specify the password. 密码: 230 Login successful. ftp&amp;gt; put a.txt 200 PORT command successful. Consider using PASV. 150 Ok to send data. 226 Transfer complete.</description>
    </item>
    
    <item>
      <title>乙一短篇摘录</title>
      <link>/posts/2022/06/yi-short-excerpt/</link>
      <pubDate>Mon, 06 Jun 2022 22:00:13 +0800</pubDate>
      
      <guid>/posts/2022/06/yi-short-excerpt/</guid>
      <description>七个房间 ——黑乙一
“我小的时候，常在老家旁边的小溪玩耍。”
据她说那是一条连溪底的石头都看得到的清澈溪流。我听着她的话，想象着犹如梦幻世界一般的那条小溪。摇摇晃晃的水面反射着太阳光，细碎的光芒闪耀着，那是一个非常明亮的世界，头顶万里无云，晴空没有尽头，仿佛自己的身体违反了重力，不断地往上再往上被吸进去似的，无边无际。
我好像开始习惯被关进的这个阴郁狭窄的水泥房间、从水沟中飘来的腐臭，以及被灯泡一照反而突显的黑暗。我开始忘记进来这里之前所待过的普通世界了。想起外面吹拂着风的世界，我不禁难过起来。
我想看天空。之前我从未有过如此强烈的渴望，被关进来之前，为什么没有多花些时间好好地眺望云朵呢？
 走过地下走廊，我们看见了一道往上的楼梯。爬到楼梯顶就是阳光灿烂的外面世界了。我们终于逃离了那个昏暗忧郁、被寂寞支配的房间。
我的眼泪掉个不停。我的脖子上挂着十字架项链，手拿着那本写着向父母道歉文章的记事本。我的手腕上挂着姐姐的遗物——那只手表。因为不是防水的表，大概在我躲进水里的时候坏掉了吧，指针恰好指着傍晚六点，停止了走动。
向阳之诗 ——白乙一
我呜咽着继续说道：“……我恨你。”
为什么要把我制造出来呢？如果我不曾诞生到这个世界喜欢上任何事物，也就不会恐惧“死亡”所带来的别离了。
虽然我已经几乎泣不成声，躺在工作台上，我还是挤出了这些话：
“我……很喜欢你，但我却必须埋葬你的遗体，这太痛苦了。如果非得这么痛苦，那我宁可不要心这种东西。我恨你，我恨你在制造我的时候，帮我装了心……”
 窗外传来了鸟鸣。我闭上眼睛，想象着数只鸟儿飞翔在蓝天的画面。合上眼帘，一直在眼眶打转的泪水便落了下来。
“但现在，我对你只有满满的感谢。如果不曾诞生到这个世界，我就无法看见小丘上辽阔的草原；如果当初你没有为我装上心，我就无法体会望向鸟巢时的愉悦，也不会因为咖啡的苦涩而皱眉了。能够这样一一地去碰触世界的光辉，是多么宝贵的事情啊！一想到这里，即使内心深处因为悲伤而淌着血，我都能够把那视为证明我活着的最最珍贵的证据……”
同时抱着感谢和憎恨的感情，或许很奇怪吧？然而，我就是这么想的。我相信大家一定都是如此。在很久以前便灭绝的人类的孩子们，对自己的父母一定也是同样怀抱着类似的矛盾情绪活下去的，不是吗？
我们都是一边学习着爱与死亡，往来于世界的向阳处与阴暗处活下去的，不是吗？
于是孩子们逐渐成长。这次，将轮到自己背负在这个世界创造出新生命的宿命，不是吗？
 我会在那座小丘上伯父长眠地的旁边掘坑；我会让你睡在里面，像是替你盖上棉被一般为你覆上泥土；我会替你立上木制的十字架，将水井边盛开的花草种在墓前；每天早上我都会去跟你道早安，到了傍晚再去向你报告这一天发生了什么。
长椅上，时间静静地流逝，正午将近。我耳中听着他体内的马达声逐渐减弱，终至再也听不见。好好安息吧。我在心中轻轻地对他说。</description>
    </item>
    
    <item>
      <title>海子的诗</title>
      <link>/posts/2022/05/haizis-poems/</link>
      <pubDate>Mon, 30 May 2022 20:11:37 +0800</pubDate>
      
      <guid>/posts/2022/05/haizis-poems/</guid>
      <description>九月 目击众神死亡的草原上野花一片
远在远方的风比远方更远
我的琴声呜咽 泪水全无
我把这远方的远归还草原
一个叫马头 一个叫马尾
我的琴声呜咽 泪水全无 远方只有在死亡中凝聚野花一片
明月如镜高悬草原映照千年岁月
我的琴声呜咽 泪水全无
只身打马过草原
 晨雨时光 小马在草坡上一跳一跳
这青色麦地晚风吹拂
在这个时刻 我没有想到
五盏灯竟会同时亮起
青麦地像马的仪态 随风吹拂
五盏灯竟会一盏一盏地熄灭
往后 雨会下到深夜 下到清晨
天色微明
山梁上定会空无一人
不能携上路程
当众人齐集河畔 空声歌唱生活
我定会孤独返回空无一人的山峦
 西藏 西藏，一块孤独的石头坐满整个天空
没有任何夜晚能使我沉睡
没有任何黎明能使我醒来
一块孤独的石头坐满整个天空
他说：在这一千年里我只热爱我自己
一块孤独的石头坐满整个天空
没有任何泪水使我变成花朵
没有任何国王使我变成王座
 面朝大海，春暖花开 从明天起，做一个幸福的人
喂马，劈柴，周游世界
从明天起，关心粮食和蔬菜
我有一所房子，面朝大海，春暖花开
从明天起，和每一个亲人通信
告诉他们我的幸福
那幸福的闪电告诉我的
我将告诉每一个人 给每一条河每一座山取一个温暖的名字
陌生人，我也为你祝福
愿你有一个灿烂的前程
愿你有情人终成眷属
愿你在尘世获得幸福
我只愿面朝大海，春暖花开</description>
    </item>
    
    <item>
      <title>《1984》文摘</title>
      <link>/posts/2022/05/1984-abstracts/</link>
      <pubDate>Thu, 19 May 2022 20:22:22 +0800</pubDate>
      
      <guid>/posts/2022/05/1984-abstracts/</guid>
      <description>作者：乔治·奥威尔
第6章 温斯顿把手垂到身边，缓慢地将肺部又吸满空气，他的大脑滑向一个双重思想的迷宫世界。知道又不知道；明白全部事实，却说着精心编造的谎言；
同时拥有两种针锋相对的意见，一方面知道两者之间的矛盾，一方面又两者都相信；
利用逻辑来反逻辑；
一方面批判道德，一方面又自认为有道德；
相信不可能有民主，另一方面又相信党是民主的保卫者；
忘掉一切需要忘记的，然后随时在需要记起时再回想起来，接着马上再忘掉——最重要的是，对这个过程本身，也要照此处理。
最奥妙之处在于：要清醒地诱导自己进入不清醒状态，然后再次意识不到刚刚对自己实行的催眠行为。
甚至理解“双重思想”这个词，也要用到双重思想。
第10章 除非他们觉醒，否则永远不会反抗；但除非他们反抗，否则不会觉醒。
第12章 一定要捍卫显而易见、质朴和真实的一切，不言而喻的就是真实的，在这一点上不可动摇！
实体世界是存在的，其定律不可改变。石头是硬的，水是湿的，缺少支撑的物体会向地心方向坠落。
怀着这种感觉，他是在向奥布兰说话，同时也在提出一条重要的公理。
他写道：自由就是说二加二等于四的自由。若此成立，其他同理。
第19章 温斯顿在床上又待了几分钟。房间内正在变暗，他往光亮处挪了一点，盯着看那块玻璃镇纸。它让人百看不厌之处，不是珊瑚，而是玻璃内部。它很厚，但又几乎像空气一样透明。那块玻璃的表面像天空的穹顶，包容了一个小小的世界，各种特点无不具备。他感觉能够进入其中，而实际上他已经身处其中，跟那张红木床、折叠桌还有钢雕版画及镇纸本身一起都在其中。镇纸就是他所在的房间，珊瑚是茱莉娅和他自己的生命，被固定在清澈透明的玻璃中心，并成为一种永恒之物。
第28章 “双重思想”意味着在一个人的脑子里，同时拥有两种相互矛盾的信念，而且两种都接受。党的知识分子明白他的记忆必须往哪个方向改变，因此他知道自己在玩弄现实，然而通过实行“双重思想”，也能让他心安理得地认为现实不曾被改变。
这个过程一定要有意识地进行，否则过程中精确度就不够；而且它也一定要无意识地进行，否则会带来一种做伪的感觉，因而会有罪过感。
“双重思想”是英社的核心，因为党最基本的行为，是进行有意识的欺骗，同时又保持目的的坚定性，那需要绝对诚实。讲着别有用心的谎言，同时又真心实意相信这些谎言；忘掉一切变得有碍的行为，然后一旦再次需要，又从遗忘中拣回来；否认客观现实的存在，同时又考虑到被否认的现实——这些都缺一不可。甚至在使用“双重思想”这个词时，也需要进行“双重思想”。因为使用这个词时，是承认在篡改现实，通过再来一次“双重思想”，就会清除这种认识，如此循环不已，谎言总跨在真实的前面。
最终以“双重思想”为手段，党就能够——我们都明白，可能在几千年内仍然能够——左右历史进程。
 作为少数派，即使是一个人的少数派，也并不能说明你疯了。世界上存在着真理和非真理，如果你坚守的是真理，即使要跟整个世界对抗，你也不会是疯的。正在下沉的夕阳把一缕黄色光线从窗户斜射进来，照在枕头上。他闭上眼睛，照在脸上的阳光和挨着他的那个女孩的光滑躯体给了他一种强烈的、催人欲睡的、自信的感觉。他是安全的，一切正常。他嘴里咕哝着“理智不是个统计学概念”就睡着了，他觉得这句话蕴藏了深刻的智慧。
第29章 每个人来说，天空都是同样的天空，无论在欧亚国或者东亚国或者这里。天空下的人们也几乎完全一样——在所有地方，包括全世界，有着上亿跟这里一样的人们，他们对彼此的存在一无所知，被仇恨和谎言之墙所隔，但仍然几乎完全一样。他们从未学会思考，但正是在他们的心里、肚子里和肌肉里，储备着某一天将推翻这个世界的力量。如果有希望，它就在群众身上！</description>
    </item>
    
    <item>
      <title>《挪威的森林》中的披头士</title>
      <link>/posts/2022/05/the-beatles-in-norwegian-forest/</link>
      <pubDate>Sat, 14 May 2022 11:47:43 +0800</pubDate>
      
      <guid>/posts/2022/05/the-beatles-in-norwegian-forest/</guid>
      <description>飞机一着陆，禁烟显示牌倏然消失，天花板扩音器中低声流出背景音乐，那是一个管弦乐队自鸣得意地演奏的甲壳虫乐队的《挪威的森林》。那旋律一如往日地使我难以自已，不，比往日还要强烈地摇撼着我的身心。
  《挪威的森林》—— Norwegian Wood   她一边这样说着，一边弹起《米歇尔》，弹得极其精彩。 “好曲子，我，无比喜欢！”说完，玲子喝了一口葡萄酒，吸了口烟，“简直就像霏霏细雨轻轻洒在无边无际的草原。”
  《米歇尔》—— Michelle   接着，她弹了《没有归宿的人》，弹了《朱丽娅》。有时边弹边闭上眼摇着头，然后又呷口酒吸口烟。
  《没有归宿的人》—— Nowhere Man 《朱丽娅》—— Julia   店里的女孩说，如果肯弹甲壳虫乐队的《太阳从这里升起》，冷藏牛奶可算店里请客。玲子伸出拇指，做出OK的表示，随即边哼歌词边弹《太阳从这里升起》。音量并不大，而且大概由于过度吸烟的关系，嗓音有些沙哑，但很有厚度，娓娓动人。我喝着啤酒，望着远山，耳听她的歌声，恍惚觉得太阳会再次从那里探出脸来，那心境实在太温馨、太平和了。
  《太阳从这里升起》—— Here Comes The Sun   “我也喜爱，非常委婉感人。”她又轻轻弹了几小节《宝贝儿》的旋律，呷了口葡萄酒。“喝醉之前能弹上几首呢。嗯，这样的葬礼不凄凉，还可以吧？” 玲子转向甲壳虫。弹了《挪威的森林》，弹了《昨日》，弹了《米歇尔》，弹了《有一件事》，边唱边弹了《太阳从这里升起》，弹了《山峰上的傻子》。我排出了七根火柴。
  《昨日》—— Yesterday 《有一件事》—— Something 《山峰上的傻子》—— The Fool On The Hill   “七首，”玲子说着，呷口酒，吸口烟。“这几个人对人生的伤感和温情确实深有体会啊。” 这几个人当然是Ｊ．列农、Ｐ．麦卡特尼，加上Ｇ．哈里森。 她换了口气，熄掉烟，又抱起吉他。弹了《细雨》，弹了《黑鸟》，弹了《朱莉娅》，弹了《年届六十四》，弹了《没有归宿的人》，弹了《而且我爱她》，弹了《喂，乔德》。
  《细雨》—— Penny Lane 《黑鸟》—— Black Bird 《年届六十四》—— When I&amp;rsquo;m Sixty Four 《而且我爱她》—— And I Love Her 《喂，乔德》—— Hey, Jude   我放上唱片，第一张听完便把唱针移到第二张。全部听完之后，又从头听起。唱片只有六张。第一张是《佩珀军士寂寞的心俱乐部乐队》，最后是比尔·埃文斯的《献给黛比的华尔兹》。窗外雨下个不停，时间缓缓流逝，直子一个人絮絮不止。</description>
    </item>
    
    <item>
      <title>《杀死一只知更鸟》文摘二</title>
      <link>/posts/2022/05/kill-a-mockingbird-digest-ii/</link>
      <pubDate>Mon, 09 May 2022 11:34:32 +0800</pubDate>
      
      <guid>/posts/2022/05/kill-a-mockingbird-digest-ii/</guid>
      <description>作者：哈珀·李
第十一章 “勇敢就是，在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。一个人很少能赢，但也总会有赢的时候。杜博斯太太赢了，全凭她那九十八磅重的身躯。用她的话来说，她死得无牵无挂，不亏欠任何人，也不依赖任何东西。她是我见过的最勇敢的人。”
第二十章 “我们都知道，某些人灌输给我们的‘人人生而平等’，实际上是个谬论——事实上，有些人就是比别人聪明睿智，有些人就是比别人享有更多的机会，因为他们生来如此，有些男人比别的男人挣钱多，有些女士做的蛋糕比别的女士更胜一筹——总而言之，有些人天生就比大多数普通人具有更高的天赋和才华。”
“但是，在这个国家里，从某种意义上来说，一切人是生来平等的——有一种人类社会机构，可以让乞丐和洛克菲勒家族的成员平起平坐，让愚人和爱因斯坦不分尊卑，让粗陋无知的人和大学校长分庭抗礼。先生们，这种机构，就是法庭——可以是美国联邦政府的最高法庭，可以是最基层的地方治安法庭，也可以是你们眼下服务的这个尊贵而神圣的法庭。我们的法庭也有缺陷，任何社会机构都不例外，但是，在这个国家里，我们的法庭是伟大的平等主义者。在我们的法庭里，人人生而平等。”
第三十一章 我心想，如果是在日光下，从这儿能一眼望到邮局所在的街角。在明亮的日光下……夜晚被我的想象驱散了，现在是大白天，整个街区的人都在忙忙碌碌。斯蒂芬妮小姐正穿过街道，把最新消息告诉雷切尔小姐。莫迪小姐正弯着腰伺弄她心爱的杜鹃花。这是夏天，两个孩子在人行道上连蹦带跳，上前去迎接从远处走来的一个男人。那个男人挥了挥手，于是两个孩子你追我赶，互不相让，朝他一路跑去。
时间依然是夏天，孩子们走近了。男孩踯躇不前，身后拖着一根鱼竿。男人两手叉腰，站在那里等他。
还是在夏天，他的孩子们在前院里和朋友一起玩耍，自编自演着一出莫名其妙的小话剧。
秋天，他的两个孩子在杜博斯太太家门前的人行道上打架。男孩把妹妹从地上扶起来，两人一起走回家去。
那个秋天，他的两个孩子一路小跑，来来回回经过那个街角，一天的烦恼和欣喜都写在脸上。他们在一棵大橡树跟前停下脚步，脸上闪过惊喜，困惑，还有点儿惶恐不安。
冬天，他的两个孩子在院门前冻得哆里哆嗦，一座房子在熊熊燃烧，火光映照出他们小小的侧影。
依然是在冬天，那个男人走上街道，扔下自己的眼镜，开枪射死了一条疯狗。
又是一个夏天，他眼看着孩子们心碎欲裂。
又到了秋天，怪人的小伙伴需要他挺身相助。
阿迪克斯说的没错。有一回他告诉我，你永远也不可能真正了解一个人，除非你穿上他的鞋子走来走去，站在他的角度考虑问题。对我来说，站在拉德利家的前廊上就足够了。</description>
    </item>
    
    <item>
      <title>《杀死一只知更鸟》文摘一</title>
      <link>/posts/2022/05/kill-a-mockingbird-digest-1/</link>
      <pubDate>Mon, 09 May 2022 11:25:47 +0800</pubDate>
      
      <guid>/posts/2022/05/kill-a-mockingbird-digest-1/</guid>
      <description>作者：哈珀·李
第九章 “杰克！看在老天的分上，当一个孩子问你问题的时候，你要正儿八经地回答，不要东拉西扯，顾左右而言他。虽说孩子毕竟只是孩子，但他们会比成人更敏锐地察觉到你在回避问题，回避只会让他们糊里糊涂。”
父亲沉吟着说道，“今天下午你的回应是对的，但你的理由有偏差。说脏话是所有孩子都会经历的一个阶段，随着他们一天天长大，他们会发现满口脏话并不能让他们成为众人瞩目的明星，他们就会改掉这个毛病。但是脾气暴躁可不好改。斯库特必须学会保持冷静，接下来的几个月里她还会经历很多事情，所以她必须尽快学会冷静面对。当然，她也在成长。杰姆长大了，她现在也能跟着学学样子。她只是在某些时候需要有人推一把。”
第十章 阿迪克斯送给我们两杆气枪之后，却不肯教我们如何射击。还是杰克叔叔教给了我们基本要领，他说阿迪克斯对枪压根儿就不感兴趣。有一天，阿迪克斯对杰姆说：“我宁愿让你们在后院射易拉罐，不过我知道，你们肯定会去打鸟。你们射多少冠蓝鸦都没关系，只要你们能打得着，但要记住一点，杀死一只知更鸟便是犯罪。”
 杰姆说：“我觉得，如果他想让我们知道，早就告诉我们了。如果他以此为豪，早就跟我们说了。”
“也许他只是没想起来。”
“不是，斯库特。这个你不懂。阿迪克斯确实老了，不过，即使他什么也做不来我也不在乎———他一件事儿都做不来我也不在乎。” 杰姆捡起一块石头朝车库扔去，一副喜不自胜的样子。他欢跳着追了过去，又回头冲我喊道：“阿迪克斯是个绅士，跟我一样！”
第十一章 “哦，大多数人好像都认为他们是对的，你是错的……”
“他们当然有权利那样想，他们的看法也有权得到充分的尊重，” 阿迪克斯说，“但是，我在接受他人之前，首先要接受自己。有一种东西不能遵循从众原则，那就是人的良心。”
 “斯库特，”阿迪克斯说，“‘同情黑鬼的人’只是一种毫无意义的称呼，跟‘鼻涕虫’一样。这很难解释清楚——有些愚昧无知的人认为有人关爱黑人胜过关爱他们，就用这个词来称呼。这个词不知不觉也成了和我们一样的普通人的日常用语，用来给人打上卑贱、丑陋的标签。”
“那你并不真的是‘同情黑鬼的人’，对吗？”
“我当然同情黑人。我尽自己所能去爱每一个人……有时候我也很为难——宝贝儿，如果别人把那当成一个侮辱性的字眼来骂你，并不能贬损你的人格。那只能让你看到，骂你的人有多可悲，他的谩骂并不能伤害到你。所以别让杜博斯太太影响你的情绪。她自己的麻烦事儿已经够多的了。”</description>
    </item>
    
    <item>
      <title>《论持久战》文摘</title>
      <link>/posts/2022/04/abstract-of-on-protracted-war/</link>
      <pubDate>Thu, 28 Apr 2022 20:27:08 +0800</pubDate>
      
      <guid>/posts/2022/04/abstract-of-on-protracted-war/</guid>
      <description>作者：毛泽东
 战争问题中的唯心论和机械论的倾向，是一切错误观点的认识论上的根源。他们看问题的方法是主观的和片面的。或者是毫无根据地纯主观地说一顿；或者是只根据问题的一侧面、一时候的表现，也同样主观地把它夸大起来，当作全体看。
 革命战争是一种抗毒素，它不但将排除敌人的毒焰，也将清洗自己的污浊。凡属正义的革命的战争，其力量是很大的，它能改造很多事物，或为改造事物开辟道路。
中日战争将改造中日两国；只要中国坚持抗战和坚持统一战线，就一定能把旧日本化为新日本，把旧中国化为新中国，中日两国的人和物都将在这次战争中和战争后获得改造。我们把抗战和建国联系起来看，是正当的。说日本也能获得改造，是说日本统治者的侵略战争将走到失败，有引起日本人民革命之可能。日本人民革命胜利之日，就是日本改造之时。这和中国的抗战密切地联系着，这一个前途是应该看到的。
 这就是所谓“唯武器论”，是战争问题中的机械论，是主观地和片面地看问题的意见。我们的意见与此相反，不但看到武器，而且看到人力。武器是战争的重要的因素，但不是决定的因素，决定的因素是人不是物。力量对比不但是军力和经济力的对比，而且是人力和人心的对比。军力和经济力是要人去掌握的。
 政治是不流血的战争，战争是流血的政治。
 错觉和不意，可以丧失优势和主动。因而有计划地造成敌人的错觉，给以不意的攻击，是造成优势和夺取主动的方法，而且是重要的方法。错觉是什么呢？ “八公山上，草木皆兵”，是错觉之一例。“声东击西”，是造成敌人错觉之一法。
在优越的民众条件具备，足以封锁消息时，采用各种欺骗敌人的方法，常能有效地陷敌于判断错误和行动错误的苦境，因而丧失其优势和主动。“兵不厌诈”，就是指的这件事情。什么是不意？就是无准备。优势而无准备，不是真正的优势，也没有主动。懂得这一点，劣势而有准备之军，常可对敌举行不意的攻势，把优势者打败。
我们说运动之敌好打，就是因为敌在不意即无准备中。这两件事——造成敌人的错觉和出以不意的攻击，即是以战争的不确实性给予敌人，而给自己以尽可能大的确实性，用以争取我之优势和主动，争取我之胜利。</description>
    </item>
    
    <item>
      <title>《挪威的森林》文摘四</title>
      <link>/posts/2022/04/norwegian-forest-digest-4/</link>
      <pubDate>Mon, 25 Apr 2022 20:39:14 +0800</pubDate>
      
      <guid>/posts/2022/04/norwegian-forest-digest-4/</guid>
      <description>第十一章 在辗转反侧的不眠之夜，我想起直子的种种音容笑貌，不容我不想起。因为我心里关于直子的记忆堆积如山，只要稍稍开启一点缝隙，它们便争先恐后，鼓涌而出，而我根本无法遏止其突发的攻势。
 就是这样，直子的形象如同汹涌而来的潮水向我联翩袭来，将我的身体冲往奇妙的地带。在这奇妙地带里，我同死者共同生活。直子也在这里活着，同我交谈，同我拥抱。在这个地方，所谓死，并非是使生完结的决定性因素，而仅仅是构成生的众多因素之一。直子在这里仍在含有死的前提下继续生存，并且对我这样说：“不要紧，渡边君，那不过是一死罢了，别介意。”
 木月死时，我从他的死中学到一个道理，并将其作为大彻大悟的人生真谛铭刻或力图铭刻在心。那便是：“死并非生的对立面，死潜伏在我们的生之中。”
实际也是如此。我们通过生而同时培育了死，但这仅仅是我们必须懂得的哲理的一小部分。而直子的死还使我明白：无论谙熟怎样的哲理，也无以消除所爱之人的死带来的悲哀。无论怎样的哲理，怎样的真诚，怎样的坚韧，怎样的柔情，也无以排遣这种悲哀。
我们惟一能做到的，就是从这片悲哀中挣脱出来，并从中领悟某种哲理。而领悟后的任何哲理，在继之而来的意外悲哀面前，又是那样软弱无力——我形影相吊地倾听这暗夜的涛声和风鸣，日复一日地此冥思苦索。我喝光了几瓶威士忌，啃着面包，喝着水筒里的水，满头沙子，背负旅行背囊，踏着初秋的海岸不断西行、西行。
 这是初秋一个天朗气清的午后——同恰好一年前我去京都探望直子时一模一样。云如枯骨，细细白白，长空寥廓，似无任何遮拦。又是一个秋天，我想。风的气息，光的色调，草丛中点缀的小花，一个音节留下的回响，无不告知我秋天的到来。四季更迭，我与死者之间的距离亦随之渐渐拉开。木月照旧十七，直子依然二十一，永远地。
 “假如你对直子的死怀有一种类似创痛之感，那么就把这种创痛留给以后的人生，在整个后半生中去体会。如若可以学习到什么，那就要从中学习。不过绿子另当别论，你要和她去寻求幸福。你的创痛与绿子无关。如果你还要伤她的心，势必导致无可挽回的后果。因此，尽管你可能心里难受，也还是要坚强起来，要再成熟一些，成为大人。我就是为了对你说这番话，才特意从疗养院跑来这里——大老远地坐着那棺材样的电车。”
 我给绿子打去电话，告诉她：自己无论如何都想跟她说话，有满肚子话要说，有满肚子非说不可的话。整个世界上除了她别无他求。想见她想同她说话，两人一切从头开始。 绿子在电话的另一头久久默然不语，如同全世界所有的细雨落在全世界所有的草坪上一般的沉默在持续。这时间里，我一直合着双眼，把额头顶在电话亭玻璃上。
良久，绿子用沉静的声音开口道：“你现在哪里？”
我现在哪里？
我拿着听筒扬起脸，飞快地环视电话亭四周。我现在哪里？我不知道这里是哪里，全然摸不着头脑。这里究竟是哪里？目力所及，无不是不知走去哪里的无数男男女女。我在哪里也不是的场所的正中央，不断地呼唤着绿子。</description>
    </item>
    
    <item>
      <title>Window实用命令记录之进程与网络控制</title>
      <link>/posts/2022/04/process-and-network-control-of-window-practical-command-recording/</link>
      <pubDate>Mon, 18 Apr 2022 23:10:39 +0800</pubDate>
      
      <guid>/posts/2022/04/process-and-network-control-of-window-practical-command-recording/</guid>
      <description>进程相关 tasklist  tasklist用于查看运行的进程 findstr相当于linux的grep  1 2 3 4  PS C:\Users\akyna&amp;gt; Tasklist | findstr Code Code.exe 19184 Console 1 94,012 K Code.exe 19300 Console 1 26,324 K ......   taskkill 使用该工具按照进程 ID (PID) 或映像名称终止任务。
参数列表:
 /PID processid 指定要终止的进程的 PID。 /IM imagename 指定要终止的进程的映像名称。 /T 终止指定的进程和由它启用的子进程。 /F 指定强制终止进程。 /? 显示帮助消息。  e.g.
1 2 3  TASKKILL /IM notepad.exe TASKKILL /PID 1230 /PID 1241 /PID 1253 /T TASKKILL /F /IM cmd.</description>
    </item>
    
    <item>
      <title>《挪威的森林》文摘三</title>
      <link>/posts/2022/04/norwegian-forest-digest-iii/</link>
      <pubDate>Mon, 18 Apr 2022 20:31:46 +0800</pubDate>
      
      <guid>/posts/2022/04/norwegian-forest-digest-iii/</guid>
      <description>第十章 一九六九年这一年，总是令我想起进退两难的泥沼——每迈一步都几乎把整只鞋陷掉那般的滞重而深沉的泥沼。而我就在这片泥沼中气喘吁吁地挪动脚步，前方一无所见，后面渺无来者，只有昏暗的泥沼无边无际地延展开去。甚至时光都随着我的步调而流淌得十分吃力。身边的人早已经遥遥领先，惟独我和我的时间在泥沼中艰难地往来爬行。
我四周的世界则面临一切沧桑巨变。约翰·科尔特兰死了，还有很多人死了。人们在呼喊变革，仿佛变革正在席卷每个角落。然而这些无一不是虚构的毫无意义的背景画面而已。我则几乎没有抬头，日复一日地打发时光。在我眼里，只有漫无边际的泥沼。往前落下右脚，拔起左脚，再拔起右脚。我判断不出我位于何处，也不具有自己是在朝正确方向前进的信心。我之所以一步步挪动步履，只是因为我必须挪动，而无论去哪里。
 下午过去，黄昏来临，继而隐隐泛青的夜色笼罩了院落。“海鸥”早已不见踪影。我又开始观看樱花。在我眼里，春夜里的樱花，宛如从开裂的皮肤中鼓胀出来的烂肉，整个院子都充满烂肉那甜腻而沉闷的腐臭气味。我转而想起直子的裸体。直子娇美的裸体横陈在夜色之中，无数植物的嫩芽从其肌肤中争相萌出，在天外来风的吹拂下，鲜绿的幼芽轻轻摇颤不止。我想，那般巧夺天工的肢体为什么非生病不可呢？他们为什么不肯放直子一条生路呢？
 “我倒想拿出精神来。”
“你把人生当做饼干罐就可以了。”
我摇了几下头，看着绿子的脸说：“可能是我脑筋迟钝的关系，有时捉摸不透你说的什么。”
“饼干罐不是装有各种各样的饼干，喜欢的和不大喜欢的都在里面吗？如果先一个劲儿挑你喜欢的吃，那么剩下的就全是不大喜欢的。每次遇到麻烦我就总这样想：先把这个应付过去，往下就好办了。人生就是饼干罐。”
“倒也是一种哲理。”
 对于只身独处的人来说，四月实在是不胜凄寂的时节。四月里，周围的人无不显得满面春风。人们脱去外套，在明媚的阳光下或聊天，或练习棒球，或卿卿我我。我却孑然一身，形影相吊。直子也好，绿子也好，永泽也好，所有的人都远远离我而去。现在的我，连问一声“早安”或“你好”的人都没有。甚至对敢死队我都有些怀念。我就这样在无可排遣的孤独中送走了四月。
 我爱过直子，如今仍同样爱她。但我同绿子之间存在的东西带有某种决定性，在她面前我感到一股难以抗拒的力量，并且恍惚觉得自己势必随波逐流，被迅速冲往遥远的前方。在直子身上，我感到的是娴静典雅而澄澈莹洁的爱，而绿子方面则载然相反——它是立体的，在行走在呼吸在跳动，在摇撼我的身心。
 就我个人感情而言，绿子倒像是个非常可贵的女孩。你为她倾心这点，从信上也看得一清二楚；而你对直子的一片痴情，我也了然于心。这并非什么罪过，只不过是大千世界里司空见惯之事。在风和日丽的天气里荡舟于美丽的湖面，我们会既觉得蓝天迷人，又深感湖水多娇——二者同一道理。不必那么苦恼。纵令听其自然，世事的长河也还是要流往其应流的方向，而即使再竭尽人力，该受伤害的人也无由幸免。所谓人生便是如此。这样说未免大言不惭——你也差不多到了学习这种人生方式的年龄。有时候你太急于将人生纳入自己的轨道。假如你不想进精神病院，就要心胸豁达地委身于生活的河流。就连我这样孱弱而不健全的女人，有时都觉得人生是多么美好。真的！所以，你也务必加倍追求幸福，为追求幸福而努力。</description>
    </item>
    
    <item>
      <title>《斜阳》文摘</title>
      <link>/posts/2022/04/setting-sun-abstract/</link>
      <pubDate>Sun, 17 Apr 2022 23:13:28 +0800</pubDate>
      
      <guid>/posts/2022/04/setting-sun-abstract/</guid>
      <description>作者：太宰治
第三章  心里没着没落，感觉好像无所凭依，似乎怎么也活不下去了——这就是所谓的不安心情吧。胸口仿佛一阵阵痛苦的浪潮在拍打、涌来，就好像黄昏时分骤雨初歇，而后天空匆匆掠过一片片白云似的，使我心脏忽而收紧，忽而松弛，脉搏失常无规律，呼吸也变得困难，眼前发黑，全身的力气仿佛从十指尖上溜掉了一样，毛线都打不下去。
 第四章  我在第一封信里曾经提到过我心中飘过的彩虹，这道彩虹并不像萤光或者星光那样高尚和美丽，假如是那样淡淡而幽远的话，我就不会这样痛苦，甚至能够逐渐将您忘掉了。我心中的彩虹是一座火焰之桥，我的思念几乎要将我的心都烧焦了。
 第五章  这人世仿佛与我所想象的人世完全不同，是一个不可言喻的奇怪世界，我似乎被人孤零零地弃之旷野，任凭我呐喊呼叫，四下却听不见任何回应。这就是所谓的失恋？
 </description>
    </item>
    
    <item>
      <title>《挪威的森林》文摘二</title>
      <link>/posts/2022/04/norwegian-forest-digest-ii/</link>
      <pubDate>Sat, 16 Apr 2022 18:03:53 +0800</pubDate>
      
      <guid>/posts/2022/04/norwegian-forest-digest-ii/</guid>
      <description>作者：村上春树
第七章 “见不到你固然是痛苦的，但倘若没有你，我在东京的生活将更不堪忍受。正因为一清早我就在床上想你，我才下决心拧紧发条，自强不息地生活下去。如同你在那边自强不息一样，我在这里也必须自强不息。”
 嘈杂的周日街头使我的心头舒展开来。我在通勤电车一般拥挤不堪的纪伊国屋书店里买了一本福克纳的《八月之光》，然后挑一家听起来声音开到尽可能大的爵士酒吧走进去，一边听奥内特·科尔曼和巴顿·帕维尔洛的唱片，一边喝又热又不好喝的咖啡，翻看刚买的书。五点半时，合上书，出门吃了简单的晚饭。我不由心想：这样的星期日以后将重复几十次、几百次吧？“安静的、平和的、孤独的星期日”——我出声说道。星期日我是不上发条的。
第八章 打桌球时居然未想起木月，这使我感到似乎做了一件对不起他的事。当时我觉得自己巳将他彻底忘在脑后，然而夜里返回宿舍，我开始这样想道：那以后已经过去了两年半，而他依然十七岁。但这并不意味他在我的记忆中已渐趋淡薄，他的死带来的东西依然鲜明地留在我的脑海里，有的反而比当时还要鲜明。我即将满二十岁，我同木月在十六岁和十七岁那两年里所共有的东西的某部分早已消失得无影无踪，无论怎样长吁短叹，都已无法挽回——我无法表达得更为确切，但我觉得对于我的感受、我想要表达的，你是会充分理解的，而且能理解此事的恐怕也只有你一个人。
 我比以前任何时候都更仔细地思考你的问题。今天在下雨，下雨的星期天多少使我有些惶惶然。因为下雨不能洗衣服，自然也不能熨衣服。既不能散步，又不能在天台上东倒西歪。只好坐在桌前，一边用自动反复唱机周而复始地听《温柔的蓝》，一边百无聊赖地观望院子的雨中景致。以前我也写过，星期天我是不上发条的，因此信也就写得很长很长。不再写了，这就去食堂吃午饭。再见。
第九章 “最最喜欢你，绿子。”
“什么程度？”
“像喜欢春天的熊一样。”
“春天的熊？”绿子再次扬起脸，“什么春天的熊？”
“春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：‘你好，小姐，和我一块儿打滚玩好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？”
“太棒了。”
“我就这么喜欢你。”</description>
    </item>
    
    <item>
      <title>《消失的十三级台阶》摘录</title>
      <link>/posts/2022/04/excerpt-from-the-lost-thirteen-steps/</link>
      <pubDate>Fri, 15 Apr 2022 13:02:21 +0800</pubDate>
      
      <guid>/posts/2022/04/excerpt-from-the-lost-thirteen-steps/</guid>
      <description>作者：高野和明
第三章 调查  人在正义的名义下审判另一个人的时候，所谓的正义并不存在普遍的标准。
  犯罪所破坏的并不仅仅是眼睛看得到的东西，而是深深地侵入人们心中，破坏了人们心中最根本的东西。 而且，人们将被这个根本性的伤害长久地困扰。
 第四章 过去  但是，如果这个社会认可私刑，社会就会陷于无秩序状态。因此，必须由第三者，也就是国家机器行使刑罚权，来代替被害人亲属做他们想做的事。是人都有复仇心，所谓复仇心，就是对失去的人的爱。只要法律是为了人类而存在的，包括死刑在内的报应刑思想就应该被认可。
 第六章 处以被告人死刑  法律这个东西，常常有被权力一方恣意滥用的危险。
 </description>
    </item>
    
    <item>
      <title>《挪威的森林》文摘一</title>
      <link>/posts/2022/04/norwegian-forest-digest-1/</link>
      <pubDate>Thu, 14 Apr 2022 23:11:22 +0800</pubDate>
      
      <guid>/posts/2022/04/norwegian-forest-digest-1/</guid>
      <description>作者：村上春树
第一章 即使在经历过十八度春秋的今天，我仍可真切地记起那片草地的风景。连日温馨的霏霏细雨，将夏日的尘埃冲洗无余。片片山坡叠青泻翠，抽穗的芒草在十月金风的吹拂下蜿蜒起伏，逶迤的薄云紧贴着仿佛冻僵的湛蓝的天穹。凝眸望去，长空寥廓，但觉双目隐隐作痛。清风抚过草地，微微拂动她满头秀发，旋即向杂木林吹去。树梢上的叶片簌簌低语，狗的吠声由远而近，若有若无，细微得如同从另一世界的入口处传来。此外便万籁俱寂了。耳畔不闻任何声响，身边没有任何人擦过。只见两只火团样的小鸟，受惊似的从草丛中腾起，朝杂木林方向飞去。
 当然，只要有时间，我总会忆起她的面容。那冷冰冰的小手，那流线型泻下的手感爽适的秀发，那圆圆的软软的耳垂以及紧靠其底端的小小黑痣，那冬日常穿的格调高雅的驼绒大衣，那总是定定地注视对方眼睛发问的惯常动作，那不时奇妙地发出的微微颤抖的语声（就像在强风中的山冈上说话一样）随着这些印象的叠涌，她的面庞突然而自然地浮现出来。最先现出的是她的侧脸。大概因为我总是同她并肩走路的缘故，最先想起来的每每是她的侧影。随之，她朝我转过脸，甜甜地一笑，微微地歪头，轻轻地启齿，定定地看着我的双眼，仿佛在一泓清澈的泉水里寻觅稍纵即逝的小鱼的行踪。
第二章 到得东京，住进寄宿舍开始新生活时，我要做的仅有一件事，那就是对任何事物都不想得过于深刻，对任何事物都保持一定距离。什么敷有绿绒垫的桌球台呀，红色的N360车呀，课桌上的白花呀，我决定一古脑儿把它们丢到脑后。还有火葬场高大烟囱中腾起的烟，警察署询问室中呆头呆脑的镇纸，也统统一扫而光。起始几天，进行得似乎还算顺利。但不管我怎么努力忘却，仍有一团恍若薄雾状的东西残留不走，并且随着时间的推移，雾状的东西开始以清楚而简洁的轮廓呈现出来。那轮廓我可以诉诸语言，那就是： 死并非生的对立面，而作为生的一部分永存。
第四章 我看看绿子的眼睛，绿子也看看我的眼睛。我搂过她的肩，吻住她的嘴。绿子只是肩头稍微抖动了一下，旋即软绵绵地闭上眼睛。约有五六秒，我们悄无声息地对着嘴唇，初秋的阳光把她的眼睫毛映在脸颊上，看上去在微微发颤。
那是一个温柔而安稳的吻，一个不知其归宿的吻。假如我们不在午后的阳光中坐在晾衣台上喝着啤酒观看火灾的话，那天我恐怕不至于吻绿子，而这一心情恐怕绿子也是相同的。我们从晾衣台上久久地望着光闪闪的房脊、烟和红脑袋蜻蜓，心情不由变得温煦、亲密起来，在无意中想以某种形式将其存留下来，于是我们接了吻，就是这种类型的吻。当然，正像所有的接吻一样，我们的接吻也不是说不包含某种危险。
第六章 之后，玲子弹了几支勃萨诺瓦舞曲。这时间里，我端详着直子。如她自己信上写的那样，她显得比以前健康，晒黑了不少，由于锻炼和野外作业，体型紧绷绷的。那湖水一般深邃澄澈的眸子和羞涩似的嗫嚅着的小嘴唇倒是和以前一样，但整个看来，她的娇美已开始带有成熟女性的风韵。往日她那娇美中时隐时现的某种锐气—— 使人为之颤栗的刀刃般的锐气—— 已经远远遁去，转而荡漾着一种给人以亲切抚慰之感的独特的娴静。我为这样的娇美而怦然心动，同时又有些感到惊愕：不过半年时间，一个女人居然会有如此明显的变化。直子这富有新意的娇美确实一如往日或甚于往日，使我为之倾心，为之痴迷。尽管如此，一想到她所失却的东西，我还是不无遗憾。那思春期少女所特有的，或者不妨称之为独往独来、我行我素的潇洒，在她身上已经一去不复返了。
 沐浴着柔和月光的直子身体，宛似刚刚降生不久的崭新肉体，柔光熠熠，令人不胜怜爱。每当她稍微动一下身子—— 虽然是瞬间微动 ——月光照射的部位便微妙地滑行开来，遍布身体的阴影亦随之变形。浑圆鼓起的乳房，小小的乳头，小坑般的肚脐，构成腰骨和阴毛的粗粒子阴影，这些都恰似静静的湖面上荡漾开来的水纹一样改变着形状。这是何等完美的肉体啊 ——我想。直子是何时开始拥有如此完美的肉体的呢？那个春夜我所拥抱的她的肉体何处去了呢？</description>
    </item>
    
    <item>
      <title>《强风吹拂》文摘</title>
      <link>/posts/2022/04/strong-wind-blowing-abstract/</link>
      <pubDate>Sun, 03 Apr 2022 23:44:25 +0800</pubDate>
      
      <guid>/posts/2022/04/strong-wind-blowing-abstract/</guid>
      <description>作者：三浦紫苑
第四章. 纪录赛登场 “看了你这三个月来的表现，我越来越相信自己没看错人，”
清濑接着说，“你很有天分，也很有潜力。所以呢，阿走，你一定要更相信自己，不要急着想一飞冲天。变强需要时间，也可以说它永远没有终点。长跑是值得一生投入的竞赛，有些人即使老了，仍然没有放弃慢跑或马拉松运动。”
阿走体内那股跑步的热情，就像一团无以名状的强烈情绪，经常在他心中掀起纷扰的涟漪。但清濑的一席话，却无比炙热地烙进他朦胧幽暗、彷徨无措的内心世界，宛如曙光乍现，照亮阿走心中每一个角落。
第九章. 奔向彼方 清濑曾经说过的“强”，或许就是这个意思。
不论个人赛或驿传，跑步需要具备的强韧，在本质上是永远不会改变的。　那是再怎么痛苦也要向前进的一种力量，以及持续与自己战斗的勇气，也是不只着眼于眼睛看得到的纪录、更要一次又一次超越自我极限的毅力。
第十章. 流星 就物理观点来看，大家都跑在同一条赛道上。
然而，每个人到达的境界却各有不同，借由跑步找到属于自己的终点。
跑者们总是不断在思考、迷惘、犯错，然后再重新来过。
尾声 ——阿走，你喜欢跑步吗？　四年前春天的夜里，清濑这样问阿走。就像一脸纯真的孩子在问，人为什么要活在这世上。　——我很想知道，跑步的真谛究竟是什么。　我也是，灰二哥，我也想知道，虽然我一直在跑，但现在我还是不知道这个问题的答案。直到现在，我跑步时都仍会思考这个问题，今后也会不停问自己。　我真的很想知道。　所以，让我们一起跑吧，跑到天涯海角。　信念发出的光芒，永远存在我们心里。在黑暗中照亮延伸向前的道路，清楚地为我们指引方向。</description>
    </item>
    
    <item>
      <title>《解忧杂货店》文摘</title>
      <link>/posts/2022/04/jieyou-grocery-store-abstract/</link>
      <pubDate>Sun, 03 Apr 2022 23:41:50 +0800</pubDate>
      
      <guid>/posts/2022/04/jieyou-grocery-store-abstract/</guid>
      <description>
作者：东野圭吾
第四章. 听着披头士默祷  人与人之间的关系往往不是因为某些具体的原因而断绝。 不，即使表面上有种原因，其实是因为彼此的心已经不在一起，事后才牵强附会地找这些借口。 因为，如果彼此的心没有分开，当发生可能会导致彼此关系断绝的事态时，某一方就会主动修复。 之所以没有人主动修复，就是因为彼此的心已经不在一起了。
 第五章. 来自天上的祈祷  你的地图是一张白纸，所以，即使想决定目的地，也不知道路在哪里。 地图是白纸当然很伤脑筋，任何人都会不知所措。 但是，不妨换一个角度思考，正因为是白纸，所以可以画任何地图，一切都掌握在你自己手上。你很自由，充满了无限可能。这是很棒的事。 我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。 这可能是我最后一次针对烦恼谘商进行回答，谢谢你在最后提供了我这么出色的难题。
 </description>
    </item>
    
    <item>
      <title>山脉游览录</title>
      <link>/posts/2022/03/mountain-tour/</link>
      <pubDate>Mon, 21 Mar 2022 18:02:04 +0800</pubDate>
      
      <guid>/posts/2022/03/mountain-tour/</guid>
      <description>山的记忆 每一座山都有独特的感觉，每一座山都有自己的故事。
我和踏过的每一座山都有一段故事。
我的山脉游览录，记录那些年那些山。
南五台 俊秀的山脉。
蓝天白云，一切都很好。
百二邱田 依稀记得这是一个清晨时的山顶。
白云密密麻麻的。
华山 悬崖绝壁，崎岖嶙峋。
对弈亭，颇具仙外境之感。
铁山 家乡的一座高山。
记得当时好像在山上迷路了。
翠华山 第一次爬雪山。
一只孤独的鸟飞了过去。
天池附近的山。
优雅的池子和静谧的山。
未来的山 &amp;hellip;&amp;hellip;</description>
    </item>
    
    <item>
      <title>在前后端不分离的情况下进行交互性数据展示的实现方法</title>
      <link>/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/</link>
      <pubDate>Fri, 11 Feb 2022 00:05:25 +0800</pubDate>
      
      <guid>/posts/2022/02/implementation-method-of-interactive-data-display-without-separation-of-front-and-back-ends/</guid>
      <description>前言 开发web项目时，常常需要在前端展示一些交互性的数据，比如表单填写错误的提示，操作成功与否的提示等。
本文主要讲述在使用Thymeleaf作为模板引擎开发前端时，即在前后端不分离的情况下，前后端进行交互性数据展示的实现方法。
使用cookie传递数据：不推荐 一、步骤  后端通过addCookie方法设置值 前端在页面加载时读取cookie值并进行展示 前端删除该cookie值  二、缺陷 这个方法我使用过，但是效果并不好，原因如下：
 用户可能禁止cookie 后端如果有重定向操作将导致cookie添加失败 前端每次都要删除cookie，有时可能会失效  使用session传递数据：值得借鉴 一、步骤  后端往session中存入数据 前端通过${session}进行获取数据并展示 前端将该数据删除或修改为指定默认值  这里注意正常情况下js是无法操作或者访问session值的，我们可以通过thymeleaf内置脚本进行操作：
1 2 3  &amp;lt;script th:inline=&amp;#34;javascript&amp;#34;&amp;gt; // 这里可以通过session访问值 &amp;lt;/script&amp;gt;   二、缺陷 这个方法不好的地方显而易见，我们每次都要删除session值，而且只能通过内置脚本的方式操作，很不方便。
但是这种方法的思想值得借鉴，请看如下方法。
通过RedirectAttributesModelMap传递数据 注意这里后端采用SpringMVC。
一、步骤  通过RedirectAttributesModelMap往model中存值 返回视图对象，在视图对象中通过thymeleaf内置脚本进行数据展示  二、示例：提醒用户首先进行登录 1、后端代码： 1 2 3 4 5  @GetMapping(&amp;#34;/loginFirst&amp;#34;) public String loginFirst(RedirectAttributesModelMap model) { model.addFlashAttribute(&amp;#34;msg&amp;#34;, &amp;#34;请先进行登录&amp;#34;); return &amp;#34;redirect:/&amp;#34;; }     RedirectAttributesModelMap可以确保redirect后保存在model中数据不丢失</description>
    </item>
    
    <item>
      <title>简洁之美</title>
      <link>/posts/2022/02/the-beauty-of-simplicity/</link>
      <pubDate>Sun, 06 Feb 2022 21:42:50 +0800</pubDate>
      
      <guid>/posts/2022/02/the-beauty-of-simplicity/</guid>
      <description>身处繁杂的社会生活 现代社会，是一个信息爆炸的时代，是一个充满无尽焦虑的时代，是一个繁杂的时代。
在离不开网络的世界里，我们难以摆脱网络上各种信息的侵扰，参差不齐的信息爬满了我们的心房。
在竞争相当激烈的当代社会，我们变得更加焦虑，思绪更加杂乱。
在难以融入的群体中，我们常常迷失了方向而变得无所适从。
想摆脱这一切，然而生活不给我们机会。
想要生活下去，必须适应这一切。
我想从这里面找到一种优美的平衡。
我想要在复杂里面寻找简洁，在焦虑中寻求冷静，在内卷中寻求内心的平衡，在群体中找到自我的位置。
我眼中的简洁美 事物的简洁不是简单的整洁，不等同于简单。
简洁，是让丰富而复杂的东西妥协，一步步削减繁琐的次要的东西，经过仔细的权衡之后留下最为重要的东西。
不能是单纯为了简洁而简化一个事物，而同时要为体验感负责，如果为了简洁削减了更重要的东西，那么就不能称得上是简洁，而是单纯沦为简单。
简洁的事物是能够让自己长久地认同的，简洁是一种趋近于内心深处的东西。
我热衷于寻求属于自己的简洁，在不断地追求这种简洁的过程中，我发现只有真正遵循于自己内心深处认同感的那种简洁，才会较为长久地留下。
也就是说，必须努力让自己冷静地，真正沉下心去寻求自己的简洁。
寻求自己的简洁 孤独 孤独的生活无需在意太多眼光与言语，尽可能地遵循自己内心的需求。
孤独的感觉是自由的感觉，没有太多的约束感。
孤独的时间让我们安静，让我们思考，而不是被无意义的言语和噪音淹没。
而身处群体中，我们无法时刻保持孤独，人类始终是摆脱不了群体。
所以，需要寻求平衡，在必须融入团体的时候应该自然地融入，去学习，去发挥作用。
生活中，要懂得去探寻属于自己的独处时间，以寻求内心的安静，去反思生活，思考人生。
合适 世界上不存在两片完全相同的叶子，每个人都是独一无二的。
适合自己的，让内心的繁杂感减轻，让自己自然地接受那种节奏，简洁的味道就出现了。
我们需要思考什么样的生活是适合自己的，什么样的生活节奏是自己可以自然地接受的。
身处竞争激烈的大环境，我认为内卷不是必须的，但努力是必要的，把握好生活的节奏是很重要的。
需要摆脱无尽的焦虑感，但也不是完全摆脱，需要保留一定的焦虑感以换取前进的动力。
如果改变不了社会，就改变自己吧，但绝不是单纯地依旧社会的要求去要求自己。
持续寻找与思考简洁 简洁的思想，启发我去寻找答案。
所有让人觉得不舒服的地方，都可以算是不简洁的，因为没有从中剔除掉多余的东西并保留下对自己有价值的东西。
我应该遵循自己的内心去面对这一切，在日常生活中寻求自己的简洁美。</description>
    </item>
    
    <item>
      <title>Linux实用操作之权限管理</title>
      <link>/posts/2021/12/permission-management-of-linux-practical-operation/</link>
      <pubDate>Mon, 20 Dec 2021 10:15:34 +0800</pubDate>
      
      <guid>/posts/2021/12/permission-management-of-linux-practical-operation/</guid>
      <description>添加用户 1 2 3 4 5 6 7 8 9  [root@VM-0-11-centos ~]# useradd jzh [root@VM-0-11-centos /]# id jzh uid=1000(jzh) gid=1000(jzh) groups=1000(jzh) [root@VM-0-11-centos /]# grep jzh /etc/passwd /etc/shadow /etc/group /etc/passwd:jzh:x:1000:1000::/home/jzh:/bin/bash /etc/shadow:jzh:!!:18980:0:99999:7::: /etc/group:jzh:x:1000:   x指代密码，对应到shadow中，未设定即为“!!”
设置密码 在进行useradd后密码还未设定。
1 2 3 4 5 6  [root@VM-0-11-centos /]# passwd jzh Changing password for user jzh. New password: BAD PASSWORD: The password is shorter than 8 characters Retype new password: passwd: all authentication tokens updated successfully.</description>
    </item>
    
    <item>
      <title>Redis学习记录二</title>
      <link>/posts/2021/12/redis-learning-record-ii/</link>
      <pubDate>Mon, 20 Dec 2021 10:15:05 +0800</pubDate>
      
      <guid>/posts/2021/12/redis-learning-record-ii/</guid>
      <description>事务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  127.0.0.1:6379&amp;gt; multi # 开启事务 OK 127.0.0.1:6379&amp;gt; set book java QUEUED 127.0.0.1:6379&amp;gt; get book QUEUED 127.0.0.1:6379&amp;gt; exec # 执行事务 1) OK 2) &amp;#34;java&amp;#34; 127.0.0.1:6379&amp;gt; get book &amp;#34;java&amp;#34; 127.0.0.1:6379&amp;gt; multi OK 127.0.0.1:6379&amp;gt; set name peter QUEUED 127.0.0.1:6379&amp;gt; discard # 取消事务 OK 127.0.0.1:6379&amp;gt; exec (error) ERR EXEC without MULTI 127.0.0.1:6379&amp;gt; get name (nil)   获取key 获取指定key 1  keys * # 获取所有key   1  keys pattern # 根据pattern获取key   1 2 3 4  - * 代表匹配任意字符 - ?</description>
    </item>
    
    <item>
      <title>Redis学习记录一</title>
      <link>/posts/2021/12/redis-learning-record-i/</link>
      <pubDate>Tue, 14 Dec 2021 23:40:44 +0800</pubDate>
      
      <guid>/posts/2021/12/redis-learning-record-i/</guid>
      <description>Open, Connect And Config  open redis:  1  redis-server   connect to redis:  1  redis-cli   disconnect:  1  redis-cli shutdown   show chinese:  1  redis-cli --raw   connect to remote redis:  1  redis-cli -h host -p port -a password   get redis config:  1  config get {config_name}   Data Type list:
1 2 3  lpush clist redis lpush clist mysql lrange clist 0 100   key:</description>
    </item>
    
    <item>
      <title>Git实用操作之初始化与分支管理</title>
      <link>/posts/2021/12/initialization-and-branch-management-of-git-practical-operations/</link>
      <pubDate>Fri, 10 Dec 2021 18:10:07 +0800</pubDate>
      
      <guid>/posts/2021/12/initialization-and-branch-management-of-git-practical-operations/</guid>
      <description>git初次拉取远程仓库  从github建立一个仓库，获取仓库地址url 进入项目所在文件夹，运行一下代码  1 2 3 4 5 6 7 8 9  &amp;gt; git init # 初始化仓库，生成.git文件 &amp;gt; git add . # 将项目文件的修改信息添加到.git内的一个暂存区（index） &amp;gt; git commit -m “init” # 将暂存区的修改信息提交到分支 &amp;gt; git remote add origin ${url} # 添加远程仓库 &amp;gt; git push origin master # 将本地分支推送到远程仓库   这里执行完 git commit -m “init”后，我们查看一下本地分支信息：
1 2  &amp;gt; git branch * master   可见git自动为我们本地创建了一个master分支。
执行完git push origin master后，我们查看一下本地分支与远程分支的映射关系：</description>
    </item>
    
    <item>
      <title>Linux实用操作之流程控制</title>
      <link>/posts/2021/12/process-control-of-linux-practical-operation/</link>
      <pubDate>Thu, 09 Dec 2021 20:33:45 +0800</pubDate>
      
      <guid>/posts/2021/12/process-control-of-linux-practical-operation/</guid>
      <description>读取输入  read -a variable_name 读取数组”array”  1 2 3 4 5 6  [root@VM-0-11-centos tmp]# read -a arr 1 2 3 4 5 [root@VM-0-11-centos tmp]# echo ${arr[0]} 1 [root@VM-0-11-centos tmp]# echo ${arr[4]} 5    read -p “prompt words” variable_name read -n limit_length variable_name  1 2 3  [root@VM-0-11-centos tmp]# read -n 5 kk words[root@VM-0-11-centos tmp]# echo $kk words    read -s variable_name “silent”输入不显示 read -t time variable_name “time”限定时间输入  条件判断语句 if else 1 2 3 4 5 6 7 8 9  if [] then do something elif [] then do something else do something fi   case 1 2 3 4 5 6 7 8 9 10 11  case ${var} in &amp;#34;condition1&amp;#34;) do something ;; &amp;#34;condition2&amp;#34;) do something ;; *) #anything do something ;; esac   循环语句 while 1 2 3 4  while [condition] do do something done   when meet the condition, start the loop.</description>
    </item>
    
    <item>
      <title>关于char*, char[], string的理解</title>
      <link>/posts/2021/12/understanding-of-char-char-string/</link>
      <pubDate>Sun, 05 Dec 2021 12:37:32 +0800</pubDate>
      
      <guid>/posts/2021/12/understanding-of-char-char-string/</guid>
      <description>关于char[]与char*的区别 1 2 3 4  char s1[] = &amp;#34;abc&amp;#34;; cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // abc s1[1] = &amp;#39;d&amp;#39;; // 改变值 cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // adc   &amp;ldquo;abc&amp;quot;为字符串常量，s1为指针常量，即指针是一个常量，所以指向地址不能改变，指向地址的值可变
1 2 3 4  const char* s2 = &amp;#34;abc&amp;#34;; // const是默认存在的 cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl; // abc s2 = &amp;#34;dfs&amp;#34;; // 改变地址 cout &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl; // dfs   &amp;ldquo;abc&amp;quot;为字符串常量，s2为常量指针，指向地址可变，但指向的地址的值不能变
以上两者皆可用于函数传值
1 2 3 4 5 6  void print_str(const char * str) { printf(&amp;#34;%s\n&amp;#34;, str); } print_str(s1); // adc print_str(s2); // dfs   关于string和char[],char*的关系  string是类，string是对一个字符串的引用值  1 2 3 4 5 6 7  const char* s1 = &amp;#34;abc&amp;#34;; string s = s1; cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; // abc s += &amp;#34;a&amp;#34;; cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; // abca cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl; // abc 证明string只是引用了s1    string引用字符串示例  1 2 3 4 5 6 7  const char *s1 = &amp;#34;123&amp;#34;; string str1 = s1; // 若要这样赋值s1必须加const cout &amp;lt;&amp;lt; str1 &amp;lt;&amp;lt; endl; // 123  char s2[] = &amp;#34;234&amp;#34;; string str2 = s2; cout &amp;lt;&amp;lt; str2 &amp;lt;&amp;lt; endl; // 234    string转char*  1 2 3  const char* s1_1 = str1.</description>
    </item>
    
    <item>
      <title>Linux实用操作之文本操作</title>
      <link>/posts/2021/12/text-operation-of-linux-practical-operation/</link>
      <pubDate>Sun, 05 Dec 2021 00:20:09 +0800</pubDate>
      
      <guid>/posts/2021/12/text-operation-of-linux-practical-operation/</guid>
      <description>使用grep抓取期望的结果 在过去登录主机的人中截取登录信息含root的行信息
1  last | grep &amp;#39;root&amp;#39;   比较重要，记忆：
grep [-acinv] [&amp;ndash;color=auto] &amp;lsquo;搜寻字串&amp;rsquo; filename
选项与参数：
-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 &amp;lsquo;搜寻字串&amp;rsquo; 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 &amp;lsquo;搜寻字串&amp;rsquo; 内容的那一行
&amp;ndash;color=auto ：可以将找到的关键字部分加上颜色的显示喔
awk命令操作文本  格式化输出：以tab隔开打印前五行中每行的第一和第三个字符  awk &amp;lsquo;{[pattern] action}&amp;rsquo; {filenames}
1  last -n 5 | awk &amp;#39;{print $1 &amp;#34;\t&amp;#34; $3}&amp;#39;   注意必须是内双引号外单引号的形式。
 分隔字符  awk -F #-F指定所操作文件中的目标分割字符
使用&amp;quot;,&amp;ldquo;分隔
1  awk -F, &amp;#39;{print $1 &amp;#34; - &amp;#34; $2}&amp;#39; log.</description>
    </item>
    
    <item>
      <title>Java重写equals方法的同时为什么要重写hashcode方法</title>
      <link>/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</link>
      <pubDate>Fri, 26 Nov 2021 09:23:27 +0800</pubDate>
      
      <guid>/posts/2021/11/why-should-java-rewrite-the-hashcode-method-when-rewriting-the-equals-method/</guid>
      <description>提出问题 先看一个例子：
当两个人年龄相同时，我们认为这两个对象相同：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Person { private int age; private String name; public Person(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return &amp;#34;Person{&amp;#34; + &amp;#34;age=&amp;#34; + age + &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() !</description>
    </item>
    
    <item>
      <title>跑步记忆</title>
      <link>/posts/2021/11/running-memory/</link>
      <pubDate>Tue, 23 Nov 2021 18:20:39 +0800</pubDate>
      
      <guid>/posts/2021/11/running-memory/</guid>
      <description>跑步的记忆，旧日的时光，思念的味道，生活的无常。
一. 跑步的挚友 念起中学生活，就会想起那位挚友。
一同骑行，跑步的挚友。
相约跑步，无话不谈。
欢快，笑颜，脚下轻快的风。
渐渐习惯了跑步。
我俩都喜欢跑步，也更喜欢骑行。
休息日，相约骑行。
去探索，去流汗，去呼吸，去感受脚下的风。
二. 离开那个地方 结束了吗，那段日子，那段纯真，自在的日子。
升学，分别，时间悄然流逝&amp;hellip;&amp;hellip;
和他的联系，不知觉地，越来越少。
跑步的日子，似乎渐渐离我而去。
跑步，对我来说意味着什么？
那段一去不返的时光，那段珍贵无比的岁月。
人走，茶凉。
三. 迷恋的感觉 高中，莫名迷上了跑步。
跑步，带给我的是不一样的感觉。
是解脱的感觉。
是在焦虑，迷茫，孤独的生活中，跑步带给我的解脱感。
跑步呵，跑步，这个孤独，奇妙的运动。
那清爽的风，那轻快的步。
那孤独的感觉，那平静的心。
我在日记记录下了那种感觉。
四. 跑步时的思考 跑步的时候，有时我也许什么都不想。
在放空心绪的状态下，感受跑步，感受风的味道。
也可能我会思考问题。
孤独的时候，常常会思考一个又一个问题。
人生，道理，题目，或是一些无意义的事情。
跑步，这项本质孤独的运动，在我看来，是免不了思考的。
思考，无疑给跑步带来了更多的乐趣。
五. 大学的风 敲着键盘，想着往事。
不知，旧日的朋友现在近况如何？
大学，还是免不了跑步。
跑步，又多了许多味道。
是思念的味道，是怀旧的味道，是寂寞的味道。
大学的风，来自西北的风，不同于南方的风，有点干燥。
感觉，一切都变了呢。
六. 伤痛的感觉 生活并不总是如你所愿。
力所不能及之处，如果非要强求，可能将落下遗憾与后悔。
山外有山，曾经有过的挑战也让我更加认清自己。
什么是最适合自己的？
自己是否努力到了足以对抗强敌的程度？
血，酒精，痛觉&amp;hellip;&amp;hellip;
一切都让我更加清醒与冷静。
反省，沉静下去反省。
愿伤痛带来的不只是伤痛。</description>
    </item>
    
    <item>
      <title>Window增加右键打开选项</title>
      <link>/posts/2021/11/add-right-click-open-option-in-window/</link>
      <pubDate>Sat, 20 Nov 2021 18:10:30 +0800</pubDate>
      
      <guid>/posts/2021/11/add-right-click-open-option-in-window/</guid>
      <description>加入注册表界面   win+R
  regedit
  增加右键操作文件选项 以vscode作为编辑文件实例 注册表页面下进入：
计算机\HKEY_CLASSES_ROOT*\shell
  新建项 Vscode
  右键Vscode并新建项command
 编辑command默认选项值为： ${vscodepath}\Code.exe %1  %1是可选的参数，这里必须要加，表示作用于该文件。
  编辑Vscode值
  编辑右键显示名称：默认值改为Open with vscode （不编辑则为新建项的名称）
  编辑右键显示图标：新建字符串值icon 添加：${vscodepath}\Code.exe (有些可以这样，但一般为ico文件)
    增加目录下右键打开选项 以window terminal作为实例 注册表页面下进入：
计算机\HKEY_CLASSES_ROOT\Directory\Background\shell
  新建项 Terminal
  右键Terminal 新建项command
 编辑command默认选项值为：${terminalpath}\wt.exe    编辑Terminal值
  编辑右键显示名称：默认值改为Open in terminal （不编辑则为新建项的名称）
  编辑右键显示图标：新建字符串值icon 添加：${terminalicon}</description>
    </item>
    
    <item>
      <title>Java中通过反射获取带参数类型的方法</title>
      <link>/posts/2021/11/get-methods-with-parameter-types-through-reflection-in-java/</link>
      <pubDate>Wed, 17 Nov 2021 23:30:04 +0800</pubDate>
      
      <guid>/posts/2021/11/get-methods-with-parameter-types-through-reflection-in-java/</guid>
      <description>问题的提出 在后端与前端进行数据传送时，需要先把数据进行类型转换，从前端获得的字符串类型（由json类型数据转化而成），转换成一个Java类。通过了解，发现可以采用导入Gson包的方式调用方法实现这个功能：
1 2 3 4  Person p = new Person(1, &amp;#34;jzh&amp;#34;); Gson gson = new Gson(); String p_json = gson.toJson(p); Person p1 = gson.fromJson(p_json, Person.class);   从中可见gson.fromJson的第二个参数就是一个类对象，针对于无参的类可以直接通过.class获取类对象，然而有参怎么办呢？如下：
1 2 3 4 5 6 7  ArrayList&amp;lt;Person&amp;gt; people = new ArrayList&amp;lt;&amp;gt;(); people.add(new Person(1, &amp;#34;jzh&amp;#34;)); people.add(new Person(2, &amp;#34;zh&amp;#34;)); people.add(new Person(3, &amp;#34;z&amp;#34;)); String ps_json = gson.toJson(people); ArrayList&amp;lt;Person&amp;gt; people1 = gson.fromJson(ps_json,new TypeToken&amp;lt;ArrayList&amp;lt;Person&amp;gt;&amp;gt;() { }.getType());   这里通过创建匿名内部类的方式实现了转换，也可以通过创建类继承于TypeToken实现。
1 2 3  class MyType extends TypeToken&amp;lt;ArrayList&amp;lt;Person&amp;gt;&amp;gt; {} ArrayList&amp;lt;Person&amp;gt; people1 = gson.</description>
    </item>
    
    <item>
      <title>Linux上部署JAR包项目后的文件上传问题</title>
      <link>/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/</link>
      <pubDate>Wed, 03 Nov 2021 00:38:12 +0800</pubDate>
      
      <guid>/posts/2021/11/file-upload-problem-after-deploying-jar-package-project-on-linux/</guid>
      <description>在进行上传文件时，一般会先获取项目类路径：
1 2  File relativePathFile = new File(URLDecoder.decode(ResourceUtils.getURL(&amp;#34;classpath:&amp;#34;).getPath(), &amp;#34;utf-8&amp;#34;)); String absolutePath = relativePathFile.getAbsoluteFile().getPath();   首先取得相对路径，再进一步取得绝对路径，结果如下：
 如果单纯运行一个java项目：  获得路径为：
${project}/target/classes
 如果是运行jar包，且是在Linux系统上，则获得路径大致为：  .../${jar包名}!/BOOT-INF/classes! [centos7.9下]
所以如果是jar包启动并上传文件，则无法正确放到类路径下。
所以需指定新的上传路径。
在如下路径中：
1 2  [root@VM-0-11-centos app]# ls application.yaml LonersHub-0.0.1-SNAPSHOT.jar static   假设我要把文件上传到和jar包同一路径下的static内, 可以在jar包同一路径下新建并编辑application.yaml文件如下：
1 2 3 4 5  spring: resources: static-locations: - classpath:static/ - file:/app/static/   然后在文件上传是指定上传路径即可。
这里编写一个工具类如下：
关注getUploadPath方法，它用于获取上传路径。
首先，为了方便后期维护和部署使用，我们先判断项目运行所在的操作系统，如果是生产环境linux则上传到上面指定的目录，而如果是本地测试项目，则将其上传到类路径下的默认位置即可。
比如，要上传一个头像：
 linux下：  返回/app/static/${uploadType}/${fileName}
e.g. /app/static/avatar/test.jpg
 window下：  返回 ${project}/target/classes/static/${uploadType}/${fileName}</description>
    </item>
    
    <item>
      <title>Linux主机部署springboot项目全过程</title>
      <link>/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/</link>
      <pubDate>Wed, 03 Nov 2021 00:30:25 +0800</pubDate>
      
      <guid>/posts/2021/11/the-whole-process-of-linux-host-deployment-springboot-project/</guid>
      <description>注：部署环境为centos7.9版本
操作步骤如下：
 配置Java环境 配置mysql环境 配置redis环境 生成，上传并运行JAR包项目  配置Java环境 前往：Linux配置Java环境
配置mysql环境   配置mysql环境，前往：Linux配置Mysql环境
  建立数据库并新建表，可通过sql脚本快速建成。
  配置redis环境  安装redis：yum install redis 启动redis：systemctl start redis 默认启动在了6379端口，如需特殊指定可在/etc/redis.conf中修改默认配置 设置开机自启动redis：systemctl enable redis  生成，上传并运行JAR包项目 上传JAR包项目 1 2  mvn clean mvn package   即可把项目打包为JAR包，再通过WINSP上传到服务器。
先新建一个app文件夹，放置项目所有内容：
1 2  mkdir /app chmod 777 /app   新建并编辑application配置文件 由于主机上的mysql密码与本地mysql密码不同，所以在JAR包同一个文件目录下新建application配置文件并指定新的密码，允许JAR项目时该application配置文件优先级是更高的。这里我还指定了用于linux下文件读取上传的目录路径。
1 2 3 4 5 6 7  spring: datasource: password: ...... resources: static-locations: - classpath:static/ - file:/app/static/   1 2 3  [root@VM-0-11-centos app]# chmod -R 777 * [root@VM-0-11-centos app]# ls application.</description>
    </item>
    
    <item>
      <title>Linux配置Java环境</title>
      <link>/posts/2021/07/configuring-java-environment-for-linux/</link>
      <pubDate>Fri, 23 Jul 2021 20:49:56 +0800</pubDate>
      
      <guid>/posts/2021/07/configuring-java-environment-for-linux/</guid>
      <description>速通  ubuntu: /etc/bash.bashrc centos: /etc/bashrc  1 2 3 4 5 6 7 8 9 10  # jdk8.sh # 安装jdk-8u311-linux-x64并配好环境变量的脚本 tar -zxvf jdk-8u311-linux-x64.tar.gz mkdir /usr/local/java mv ./jdk1.8.0_311 /usr/local/java echo &amp;#39;# java env&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export JAVA_HOME=/usr/local/java/jdk1.8.0_311&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export PATH=$JAVA_HOME/bin:$PATH&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc echo &amp;#39;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&amp;#39; &amp;gt;&amp;gt; /etc/bash.bashrc source /etc/bash.bashrc   下文是分步解释。
获取JDK 首先下载jdk压缩包，然后解压缩jdk压缩包：
1 2 3 4 5 6  [root@VM-0-11-centos ~]# ls bin jdk-8u311-linux-x64.tar.gz passwd var [root@VM-0-11-centos ~]# tar -zxvf jdk-8u311-linux-x64.</description>
    </item>
    
    <item>
      <title>春物文摘四</title>
      <link>/posts/2021/06/spring-abstracts-iv/</link>
      <pubDate>Wed, 23 Jun 2021 23:27:20 +0800</pubDate>
      
      <guid>/posts/2021/06/spring-abstracts-iv/</guid>
      <description>作者：渡航
卷十三 第八章. 祈祷至少不要再出错。 「我过得很愉快。这还是第一次。觉得跟别人一起度过的时间是自在舒适的，我很高兴……」
她带着泫然欲泣的表情，看起来真的很幸福。我再也无法否定，制止她。
我无力地放下手，雪之下道谢似地点一下头，接着说：
「我从来没有像这样跟别人争执，吵架……在别人面前哭过。两个人一起出去的时候，也非常紧张。一堆事都不懂，从来没有体验过……连可以依赖别人都不知道。所以，才会在哪里搞错了……」
我抬头看着天花板，倾听她用颤抖的声音自言自语。
远方的夕阳刺痛双眼，即使如此，我依然无法闭上眼，只是忧郁地吐出一口气。
「这种像赝品的关系是错误的。和你追求的事物肯定不一样。」
卷十四 序章1 季节轮转，春日再临。
即便重复着一成不变的日常，今日也总是崭新的。
即便困于烦恼，难觅答案，重复着错误，也只能不厌其烦地重新问过——为了知晓新的答案。
不付诸言语便无法传达，可就算说出口也仍不足够。
无论何时得出的答案都是错误的，扭曲得几近无法挽回的关系，是令人无可奈何的伪物。
———所以，至少，要在这个仿造品上留下足以毁坏的伤痕，变成那仅仅只有一个的真物。
我故意犯错的青春，要让它结束掉———
已然逝去的季节，与将要来临的崭新季节。
持续着错误的故事结束……之后青春一定还将继续。
第七章. 触碰到的温度，切实地传达着那份情感 在她走了几步之后，我跟了上去。
看着远去的背影，我伸出了手，却又不由地犹豫起来。
我明白，如果要继续谈话的话，只要叫住她就行了。
即使继续像那样走下去，交谈也并不困难。
再说了，根本不可能没有特别的理由就去触碰她的手。
但是，理由确实存在。唯一的，不容退让的理由。
「……放手了的话，就再也抓不住了啊」
脱口而出的话语，就像是在说给自己听一样。
不对，是为了说给自己听才会说出那样的话。接着，我伸出了手。
单手推着自行车我的样子有些狼狈，而且手里还出了很多汗，也不清楚该用多大的力道。
即便如此，我还是抓住了雪之下的袖口。
把那纤细到令我惊讶的手腕紧紧地收入掌中。
「…………」
 开始说话之后，由于强烈的自我厌恶手中的力气不断地减弱。
说出这种话的自己简直恶心得令人作呕。
抓着雪之下的手腕的手一点点下滑，松开，然后无力地垂落下去。
但是，雪之下并没有逃走，而是停在了那里。
在摸了摸袖口稍作整理的时候，用自己的手紧握住方才被我抓住的地方。
虽然没有看向我这边，但是至少看上去有继续听下去的意思。
对此感到安心之后，我不紧不慢地开口道。
「可能你并不期望……但是我想把关系维持下去。不是义务，而是意愿的问题。……所以，给我扭曲你人生的权利」
 「我没有足以改变人生的影响力啊，大概，我和你也都会像其他人一样升学，不情愿地就职，就那样认真地活着。但是，互相关联之后，会莫名其妙地做出绕远路啊，原地踏步啊之类的各种各样的事情吧……所以，人生会稍微扭曲一些」
「我也是这么想的，相遇，相谈，相知，相离……每次，都会感到扭曲」
 想必，太过别扭的我，太过直率的她，在他人眼中都是扭曲的形状吧。
虽然完全没有相同之处，在扭曲这一点上恐怕是一样的。
不知不觉间，每一次的相触，每次一次的碰撞，都在稍稍改变了我们的形状。
这样的改变不断累积，已经到了无法还原的地步了。
 如果有让传达变得更简单的话语就好了。
如果是更加单纯的感情就好了。
如果只是恋慕、思慕的话一定不会这么向往。『再也抓不住』什么的，不会这么想。
「应该不足以支付扭曲人生的代价吧，不过嘛，全都会去做的。不需要的话就扔掉吧。嫌麻烦的话忘掉也无所谓。是我这边擅自做出的决定你不用勉强自己回复」
雪之下轻哼了一声，点了点头。
「我要好好说了哦」
然后，轻轻地把额头抵在我的肩口。
「你的人生，请交给我吧」
「……好沉重」
不经意间，气息漏出了我的嘴角。仿佛是在抗议一般，雪之下的额头再一次轻轻地撞了过来。
「真的不知道其他的说法了，所以这也是没办法的啊……」
她像猫一样把额头靠了过来，仿佛小猫轻咬一般抓着我的胸膛。
触碰到的温热，一定在确切地传达着用千言万语也说不清的心意。
第八章. 那扇门再次打开。 我默默地把手递了过去。</description>
    </item>
    
    <item>
      <title>Docker简单使用过程记录</title>
      <link>/posts/2021/05/docker-simple-use-process-record/</link>
      <pubDate>Wed, 19 May 2021 22:52:52 +0800</pubDate>
      
      <guid>/posts/2021/05/docker-simple-use-process-record/</guid>
      <description>开启docker服务 1 2  [root@VM-0-11-centos ~]# curl -sSL https://get.daocloud.io/docker | sh [root@VM-0-11-centos ~]# systemctl start docker   测试docker 一、下载ubuntu镜像
1 2 3 4 5 6 7 8 9 10 11 12  [root@VM-0-11-centos ~]# docker run ubuntu:15.10 /bin/echo &amp;#34;hello world&amp;#34; Unable to find image &amp;#39;ubuntu:15.10&amp;#39; locally 15.10: Pulling from library/ubuntu 7dcf5a444392: Pull complete 759aa75f3cee: Pull complete 3fa871dc8a2b: Pull complete 224c42ae46e7: Pull complete Digest: sha256:02521a2d079595241c6793b2044f02eecf294034f31d6e235ac4b2b54ffc41f3 Status: Downloaded newer image for ubuntu:15.</description>
    </item>
    
    <item>
      <title>Synchronized到底锁了谁</title>
      <link>/posts/2021/05/who-the-hell-is-synchronized-locking/</link>
      <pubDate>Wed, 19 May 2021 22:43:45 +0800</pubDate>
      
      <guid>/posts/2021/05/who-the-hell-is-synchronized-locking/</guid>
      <description>Synchronized方法   静态方法上的锁
静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个类。
  普通方法上的锁
实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。在实例方法上加入synchronized，那么它获取的就是这个类的锁，锁住的就是这个对象实例。
  Synchronized代码块  synchronized(this){...}  this关键字所代表的意思是该对象实例，这种用法synchronized锁住的是对象实例。
 synchronized(Demo.class){...}  锁的是该类。
 synchronized(obj){...}  synchronized同步代码块对对象内部的实例加锁。
假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，均能获取各自的锁。
代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class Demo { private Object lock1 = new Object(); private Object lock2 = new Object(); public void demo1() { synchronized (lock1) { while (true) { //死循环目的是为了让线程一直持有该锁  System.</description>
    </item>
    
    <item>
      <title>Git实用操作之解决冲突</title>
      <link>/posts/2021/05/conflict-resolution-of-git-practical-operation/</link>
      <pubDate>Wed, 19 May 2021 22:12:54 +0800</pubDate>
      
      <guid>/posts/2021/05/conflict-resolution-of-git-practical-operation/</guid>
      <description>首先提交当前分支修改：
1 2  git add . git commit -m &amp;#34;msg&amp;#34;   这时如果其他分支对当前提交分支进行了修改，直接push上去则会失败并提醒进行冲突的解决。
因此，进行pull，将更改拉取下来进行冲突的解决。
1  git pull   这时有2种可能的情况，要么其他分支的修改地方和自己的修改的地方不冲突，要么冲突。
如果不冲突且接受其他分支的容易修改，则可以直接push上去了。
如果冲突了，则对所有冲突的地方merge，即在提示冲突的地方进行修改的选择即可。
1 2 3 4 5  &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD hello world ======= hello kitty &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; another-branch   HEAD标记&amp;quot;Current Change&amp;quot;，即当前分支的修改，&amp;ldquo;another-branch&amp;quot;标记其他分支的修改，两者之间用&amp;rdquo;===&amp;ldquo;隔开。
修改完成后，重新进行完整的提交即可：
1 2 3  git add . git commit -m &amp;#34;msg&amp;#34; git push   over.</description>
    </item>
    
    <item>
      <title>春物文摘三</title>
      <link>/posts/2021/05/spring-article-excerpt-3/</link>
      <pubDate>Thu, 13 May 2021 23:19:00 +0800</pubDate>
      
      <guid>/posts/2021/05/spring-article-excerpt-3/</guid>
      <description>作者：渡航
卷十 第七章. 不论何时，叶山隼人总是迎合众人期待 她满意地舒一口气，把脸抬起。我们之间的距离，瞬间拉近到脸颊快碰在一起。
「……」
两个人就这么僵住。
雪之下的肌肤宛如冬天的白雪，乌黑的双眼仿佛在荡漾，每眨一下，修长的睫毛跟着轻柔摇曳。往底下走，是姣好尖挺的鼻梁，以及绽放笑容、呼出热气的嘴唇。
她削瘦的的肩膀微微一颤，瀑布般的长发随之晃动。
我赶紧往后仰，跟她拉开距离。结果不知动到什么地方，某处的伤口突然痛了一下。
「嗯……谢谢你帮忙消毒。」
「……没什么，不是什么大不了的事。」
卷十二 第五章. 果然，一色彩羽是最强的后辈。 舞会上的雪之下
倒不如说合身过头了。单色调的燕尾服，更彰显了雪之下白皙明净的肌肤之美；
伸长的衣摆和长裤也令她修长俏丽的美腿更为凸显；
举手投足间，她那扎为一束的秀发如波浪般律动，又为她添了几分虚幻朦胧之意；
再与她纤瘦的身材相映成趣后，「薄幸的美少年」一词仿佛呼之欲出。
光是她那工整标致的五官，便使她散发着一种倒错美的气息，我甚至感到了危险。
 舞会上的结衣
近乎于白的淡粉、带着透明感的布料，此般色调搭配，又或者说是因为这种款式，给人一种分外的成熟感。
衣襟张得很开，腰部那块也束了一圈，而这又更勾勒出她傲人的身体曲线。
裙摆本身很长，不过因为开衩开的很深，所以看上去丝毫不笨重；倒不如说若是她转动身体，这礼服就好似随风起舞般的轻盈。
她一向缠成团子头的头发，如今编的好似花冠，让我不禁想起某位王子大人提过的称呼。
第七章. 就算，知道会后悔这个选择。 最终只剩下我们的事了。因为相互依赖，所有没有比我们更好理解的了。
说来容易，正因被人依靠，我才能够弄清自己的存在价值。
我自己也很容易地信服。
然而，这并不是答案。相互依赖是形式，但非人的感情所在。即便可以用作借口，也无法成为理由。
抽丝剥茧，尽心竭力，声嘶力竭，最终心里只剩下了恋恋不舍。
可是，我唯独不想说出这话。因为这个理由太逊了。然而，不说出来，这位老师就不会让我前行。我很清楚，因为如此，她才对我道歉。
所以，我疲惫地、重重地叹了一口气，迫不得已，小声地开口说道。
「……因为我承诺过，总有一天会对她伸出援手。」
因为她拜托过我，这理由十分平常而又极为理所当然，这话语不带感情而又毫无逻辑可言，这措辞实在无聊而又陈词滥调透顶，我对向她出手相助，真的是厌恶至极。</description>
    </item>
    
    <item>
      <title>春物文摘二</title>
      <link>/posts/2021/05/spring-abstracts-ii/</link>
      <pubDate>Tue, 11 May 2021 16:44:36 +0800</pubDate>
      
      <guid>/posts/2021/05/spring-abstracts-ii/</guid>
      <description>作者：渡航
卷八 第一章. 不用说也知道，这正是比企谷小町的逆鳞所在 我们终将失去拥有的一切。此乃不变的真理。
尽管如此——
因为终将失去，才显现其美丽。
因为有结束的一刻，才显得有意义。不论是停滞还是闭塞，乃至于一时的安宁，都绝非我们所能忽视或甘愿忍受的事。
万物皆有失去的一刻。千万谨记这一点。
在不经意间想起失去的事物，如同对待宝物般小心呵护，将回忆连同杯中的酒一起饮尽，想必也是一种幸福。
第七章. 不用说也知道，这正是比企谷小町的温柔所在 谁也不会受到伤害的世界根本不存在。
真正存在的，是大家平等受到伤害的世界。
没有人受到伤害，这个世界便无法成立。如果明白这一点，依然不愿任何人受伤，那只好另外产生一个代罪羔羊。
这个代罪羔羊不是从任何人之中推派，它只负责出来扛下所有的憎恨与伤害。
第八章. 时机成熟，比企谷八幡终于开口 我真的不知道答案如何。
雪之下的那句话依旧在耳边回荡。
认为对方了解自己只是一种幻想，如同让人忘却自我的温柔乡，一旦深陷进去便难以脱身。抛下一切委身于其中，真不知道会有多舒服。
「相互了解」是一种错觉，一场残酷的幻术。
从幻术中回过神时，那股失落感想必相当强烈。
任何一点微小的不自然感与疑心会成为荆棘与隔阂，在某个时刻将一切摧毁殆尽。
我应该早一点有所察觉。
我渴望的不是什么亲近的关系。
我渴望的事物更加纯粹。
无需话语即可心意相通，无需行为即可了解对方，无论发生什么都能永保完整——我真正渴望的是这种超脱现实，到达可笑地步的美丽幻想。
这是我跟她一直在追求的事物。
卷九 第五章. 平冢静祈祷着他们迎向的结局 雪之下摇摇头，肩上的包包无力地滑落。
「在那之后，你便一直很在意……所以……」
我好不容易听出气若游丝的话语，等待她的下一句话。她却转向别的话题。
「其实，你不需要继续勉强自己。要是这样就被破坏，代表程度也不过如此……难道不是？」
这次我真的说不出话。
雪之下所说的，是我曾经相信过，却没有坚信到底的事物。
毕业旅行之后，我便不再相信的事物，雪之下至今仍深信着。
 街灯将平冢老师的脸映照成橘红色，川流的车灯不时刷上白光。她带着略显落寞的神情，用温暖又柔和的声音低语：
「可是啊，比企谷，这是不可能实现的。人类只要存在这个世界，便难免在不自觉中伤害到其他人。不只是活着，连死去以后，伤害都持续发生着。与人产生关系，伤害便连带出现；即使刻意避免产生关系，也难保对方不会受伤……」
平冢老师抽出一根香烟，看着那根烟继续说：
「说是这么说，假如对方一点都不重要，我们也不会注意到自己造成的伤害。重要的在于『自觉』。正是因为珍惜对方，我们才意识到伤害了对方。」
老师总算把烟含入口中，用打火机点燃时，脸庞微微亮了一下。她闭着双眼，面容相当安详，「呼——」地吐出长长的烟雾，低语：
「珍惜一个人，意味着做好伤害对方的觉悟。」
她抬头看向夜空。
第六章. 即使如此，比企谷八幡—— 我渴望的不是话语。但我的确渴望着什么。
那肯定不是相互理解、好好相处、无话不谈、待在一起之类的愿望。我知道自己不被人理解，也不期望别人理解自己。
我追求的是更苛刻、更残酷的事物。
未知的事物是何等恐怖，所以我希望「了解」。我想了解、想知道，借此感到安心，得到心灵上的安适。
「想要完全理解」这种愿望太过自私、太过独裁、太过傲慢，既肤浅又教人厌恶。一想到自己抱持这种愿望，便觉得浑身快要受不了。
话虽如此，如果、如果彼此都能这么想——
如果存在那么一个对象，能互相将丑陋的自我满足加在彼此身上，并且建立容忍彼此傲慢的关系——
这种情况绝对不可能发生，我心里清楚得很；这样的愿望，只存在我无法企及之处。
再怎么跳也够不到的葡萄，一定酸得要命。
不过，我也不需要甜到失去实感的果实。虚假的认知和欺瞒的关系，不是我渴望的事物。
我渴求的，其实是酸得要命的葡萄。
哪怕那串葡萄再酸、再苦涩、再难吃、甚至有毒，或根本不存在、不可能得到、连「想要」的想法都不被允许——
「即使如此……」
等察觉时，话语已经脱口而出。我听得出自己的声音在颤抖。
「我还是……」
我用尽全力避免自己哽咽，牙根发出咯吱声响。尽管想把声音跟话语通通吞回去，它们却一而再地突破我的齿缝。
「我还是，想得到『真物』。」
第八章. 于是，雪之下雪乃—— 雪之下望着下方的景色，发出一阵轻叹。
「比企谷同学。」</description>
    </item>
    
    <item>
      <title>Java与C&#43;&#43;中的值传递和引用传递解析</title>
      <link>/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</link>
      <pubDate>Sat, 01 May 2021 20:16:39 +0800</pubDate>
      
      <guid>/posts/2021/05/value-passing-and-reference-passing-parsing-in-java-and-c/</guid>
      <description>先说结论：Java只有值传递，而C++既有值传递又有引用传递。
Java的参数传递 先定义3个方法如下：
1 2 3 4 5 6 7 8 9 10 11  public static void change1(String str, int num) { str = &amp;#34;world&amp;#34;; // 这里就相当与新new了一个对象!  num = 100; } public static void change2(User user) { user.age = 1; user.name = &amp;#34;mary&amp;#34;; } public static void change3(User user) { user = new User(1, &amp;#34;mary&amp;#34;); }   进行测试：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void main(String[] args) { String str = &amp;#34;hello&amp;#34;; int num = 1; System.</description>
    </item>
    
    <item>
      <title>Window实用命令记录之文件操作</title>
      <link>/posts/2021/04/file-operation-recorded-by-window-utility-command/</link>
      <pubDate>Mon, 19 Apr 2021 13:48:19 +0800</pubDate>
      
      <guid>/posts/2021/04/file-operation-recorded-by-window-utility-command/</guid>
      <description>创建文件或文件夹 cmd下创建文件 1  type nul &amp;gt; test.jpg   powershell下创建文件 1  new-item test.jpg   创建文件夹 1  mkdir test   重命名文件 注意不能指定到新的路径。
1  PS D:\a\tmp\test&amp;gt; ren test.txt my.txt   移动文件 该命令也可用于重命名。
1  PS D:\a\tmp\test&amp;gt; move test.jpg mydir   复制文件和文件夹 copy无法递归复制，而xcopy可以。
1  PS D:\a\tmp\test\mydir&amp;gt; copy test.jpg test1.jpg   1 2 3 4 5 6 7 8 9 10 11 12  # mydir not empty PS D:\a\tmp\test&amp;gt; copy mydir mydir1 PS D:\a\tmp\test&amp;gt; ls mydir1 # empty PS D:\a\tmp\test&amp;gt; xcopy mydir mydir2 目标 mydir2 是文件名 还是目录名 (F = 文件，D = 目录)?</description>
    </item>
    
    <item>
      <title>Linux实用操作之shell变量运算</title>
      <link>/posts/2021/04/shell-variable-operation-of-linux-practical-operation/</link>
      <pubDate>Mon, 12 Apr 2021 23:21:41 +0800</pubDate>
      
      <guid>/posts/2021/04/shell-variable-operation-of-linux-practical-operation/</guid>
      <description>算术运算 1 2 3 4 5 6 7 8 9  [root@VM-0-11-centos ~]# a=1 [root@VM-0-11-centos ~]# echo $a 1 [root@VM-0-11-centos ~]# b=$((a*12)) [root@VM-0-11-centos ~]# echo $b 12 [root@VM-0-11-centos ~]# b=$((b+b)) [root@VM-0-11-centos ~]# echo $b 24   比较运算 指令：-eq -ne -lt -gt -ge -le
1 2 3 4 5  a=10 [root@VM-0-11-centos ~]# [ $a -eq 10 ] &amp;amp;&amp;amp; echo yes yes [root@VM-0-11-centos ~]# [ $a -ge 11 ] &amp;amp;&amp;amp; echo yes || echo no no   指令：-a -o</description>
    </item>
    
    <item>
      <title>《人间失格》文摘</title>
      <link>/posts/2021/04/human-disqualification-abstract/</link>
      <pubDate>Sun, 11 Apr 2021 23:13:01 +0800</pubDate>
      
      <guid>/posts/2021/04/human-disqualification-abstract/</guid>
      <description>作者：太宰治
手记之二 新学年伊始，山樱树在强韧的褐色嫩叶烘托和蔚蓝的大海映衬下，绽放绚烂的花朵，待到落英缤纷时节，如飞雪般坠下的樱花飘飘洒洒散向大海，装点着海面，随波荡漾，被浪花复又拍打回岸边。
 真孤单……比起她冗长的身世来，仅就这一句叹息便足以唤起我的共鸣。我一直期待着，可是，我从未从这世上的女人口中听到过这句话，这使我感到奇怪和难以理解。不过，虽然她没有用语言说出“孤单”两字，但似乎她身上就散发着这般无言的孤寂，好似有股一寸来宽的气流带包裹着她，在她身旁，我好像也被那股气流包裹，与我特有的带刺的阴郁气流相互交融，犹如落入水底附着在岩石上的枯叶，使我得以从恐惧和不安中抽离。
手记之三 他面容下潜藏着某种狡诈嗤笑的那一刻，令我永远难以忘怀。那东西似轻蔑，却又有所不同，倘若将人世间比作大海，在那千丈深的海底就漂摆曳动着那种诡异的面容，仿佛故意露出隙孔，让人一窥成年人生活的深层奥趣似的——就是那种笑。</description>
    </item>
    
    <item>
      <title>春物文摘一</title>
      <link>/posts/2021/04/spring-abstracts-i/</link>
      <pubDate>Sun, 11 Apr 2021 11:51:03 +0800</pubDate>
      
      <guid>/posts/2021/04/spring-abstracts-i/</guid>
      <description>作者：渡航
卷二 第五章. 比企谷八幡再一次回归原来的道路 「才不是那样子……根本不是那样……」
她说得很小声。由比滨总是那么温柔，所以直到最后仍旧温柔。
如果说真相是残酷的，那么谎言想必很温柔。所以，温柔只是一种谎言。
卷四 第五章. 雪之下雪乃独自仰望星空 每个人都会为过去所困，不论我们自以为已经往前走多远，只要在不经意间抬起头，往事便像星光一样缓缓降下。
我们无法一笑置之，也无法把它们变不见。
那些事情永远会待在我们心中的一角，与某个时刻突然苏醒。
卷六 第十章. 他跟她终于找出正确的答案 「比企谷，帮助其他人不能当做伤害自己的理由。」
鼻腔内是淡淡的香烟味，脸上是难以想像为同一个人的温柔指尖。她潮湿的双眼，有如看透我的内心。
「不，这种程度不至于让我受伤……」
「……就算你已经习惯那种痛也一样。过了这么久，你总该明白有些人看到你受伤，一样会觉得心痛。」
卷七 第六章. 雪之下雪乃安静地走在夜晚的街道 但是，我没有见过这样的雪之下。
她不断注意周遭，同时看着我的脚边，以免找不到回去的路。
她难为情地垂下双眼，发现我走太快时，还伸出犹豫不决的手，想要我放慢速度，接着又惊觉似地把手缩回——我从来没见过这些举动。
我被她生硬的举动感染，不知不觉间变得同手同脚，也因为如此，尽管旅馆离这里很近，我却觉得远得要命。
我们两人始终若即若离，怎样都不会并肩走在一起。</description>
    </item>
    
    <item>
      <title>Linux实用操作之编辑命令与变量</title>
      <link>/posts/2021/04/editing-commands-and-variables-of-linux-practical-operation/</link>
      <pubDate>Mon, 05 Apr 2021 23:01:48 +0800</pubDate>
      
      <guid>/posts/2021/04/editing-commands-and-variables-of-linux-practical-operation/</guid>
      <description>配置环境变量（以Java为例） Linux相关配置文件解析  bashrc部分:   /etc/bashrc: 针对所有用户，每开启一个shell都会执行一次 /etc/skel/.bashrc: 针对所有用户，用于在新建一个用户时默认给用户配置的bashrc ~/.bashrc: 只针对单个用户，每开启一个shell执行一次  profile部分:   /etc/profile: 针对所有用户，首次登录执行一次 /etc/skel/bash_profile: 针对所有用户，用于在新建一个用户时默认给用户配置的bashr_profile ~/.bash_profile: 只针对单个用户，首次登录执行一次  编辑/etc/bashrc文件 也可以选择编辑/etc/profile。
1 2 3 4 5 6 7 8  [root@VM-0-11-centos ~]# vim /etc/bashrc # 进行全局配置 进行添加如下： #JAVA export JAVA_HOME=/usr/local/java/jdk1.8.0_311 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar    使配置文件生效：  1  source /etc/bashrc   验证Java环境： 1 2 3 4 5 6 7 8 9  [root@VM-0-11-centos ~]# java -version java version &amp;#34;1.</description>
    </item>
    
    <item>
      <title>Linux实用操作之文件操作</title>
      <link>/posts/2021/04/file-operation-of-linux-practical-operation/</link>
      <pubDate>Mon, 05 Apr 2021 22:38:46 +0800</pubDate>
      
      <guid>/posts/2021/04/file-operation-of-linux-practical-operation/</guid>
      <description>观察文件信息 1 2  drwxr-xr-x 2 root root 4096 Jan 2 18:41 source 文件类型+文件权限+目录或链接个数+创建者+所在组+文件大小+修改日期+名称   关于文件类型：
 d: directory -: file l: link p: pipeline，管道文件 b: block，块设备文件 c: character，字符设备文件 s: socket，套接字文件  文件创建 1 2 3 4 5 6 7 8 9  [root@VM-0-11-centos d3]# touch f1 [root@VM-0-11-centos d3]# ll total 0 -rw-r--r-- 1 root root 0 Apr 10 00:26 f1 # -d 修改创建时间 [root@VM-0-11-centos d3]# touch -d &amp;#34;2022/4/10 00:27&amp;#34; f1 [root@VM-0-11-centos d3]# ll total 0 -rw-r--r-- 1 root root 0 Apr 10 00:27 f1   目录创建 1 2 3 4  [root@VM-0-11-centos test]# mkdir -p d1/d2/d3 [root@VM-0-11-centos test]# cd d1/d2/d3 [root@VM-0-11-centos d3]# pwd # 查看当前路径 /root/test/d1/d2/d3   文件移动 1 2 3 4 5  [root@VM-0-11-centos test]# ls t1.</description>
    </item>
    
    <item>
      <title>Linux实用操作之进程管理</title>
      <link>/posts/2021/03/process-management-of-linux-practical-operation/</link>
      <pubDate>Wed, 31 Mar 2021 22:55:53 +0800</pubDate>
      
      <guid>/posts/2021/03/process-management-of-linux-practical-operation/</guid>
      <description>查看所有进程 ps -ef  -e : all processes (-A) -f : full-format, including command lines  1 2  [root@VM-0-11-centos ~]# ps -ef | head -n 1 UID PID PPID C STIME TTY TIME CMD   解释如下：
 PPID 父进程ID C 占用CPU百分比 STIME 就是&amp;quot;start time&amp;quot; TTY 进程在哪个终端显示 CMD 命令的名称和参数  ps aux  a: all with tty, including other users (和-a是不同的) u: user-oriented format x: processes without controlling ttys  1 2  [root@VM-0-11-centos ~]# ps -aux | head -n 1 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND   解释如下：</description>
    </item>
    
    <item>
      <title>Linux实用操作之工作调度</title>
      <link>/posts/2021/03/job-scheduling-of-linux-practical-operation/</link>
      <pubDate>Wed, 31 Mar 2021 22:34:24 +0800</pubDate>
      
      <guid>/posts/2021/03/job-scheduling-of-linux-practical-operation/</guid>
      <description>at命令 create job 1 2 3 4 5 6 7 8 9 10  [root@VM-0-11-centos ~]# at 22:38 at&amp;gt; echo &amp;#34;hello world&amp;#34; &amp;gt; ~/at-test.txt # ctrl D at&amp;gt; &amp;lt;EOT&amp;gt; job 3 at Thu Mar 31 22:38:00 2022 [root@VM-0-11-centos ~]# at now +2 minute at&amp;gt; echo &amp;#34;hello kitty&amp;#34; &amp;gt;&amp;gt; ~/at-test.txt # ctrl D at&amp;gt; &amp;lt;EOT&amp;gt; job 4 at Thu Mar 31 22:39:00 2022   check job 1 2 3 4 5 6 7 8 9 10 11 12 13 14  [root@VM-0-11-centos ~]# ls at-test.</description>
    </item>
    
    <item>
      <title>Linux实用操作之网络管理</title>
      <link>/posts/2021/01/network-management-of-linux-practical-operation/</link>
      <pubDate>Sun, 03 Jan 2021 00:27:58 +0800</pubDate>
      
      <guid>/posts/2021/01/network-management-of-linux-practical-operation/</guid>
      <description>查看内网IP grep抓取inet行，sed删除inet字串和netmask.*字串
1  alias myip=&amp;#34; ifconfig eth0 | grep &amp;#39;inet &amp;#39; | sed &amp;#39;s/inet//g&amp;#39; | sed &amp;#39;s/netmask.*$//g&amp;#39;&amp;#34;   test:
1 2  [root@VM-0-11-centos ~]# myip 172.17.0.11   查看外网IP 1  curl cip.cc   show:
IP : ${my_ip} 地址 : 中国 中国
数据二 : 上海市 | 腾讯云
数据三 : 中国北京北京 | 腾讯
URL : http://www.cip.cc/${my_ip}
查看IP端口状况 1 2 3 4 5 6  [root@VM-0-11-centos ~]# netstat -ntlp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.</description>
    </item>
    
    <item>
      <title>Linux实用操作之修改默认配置</title>
      <link>/posts/2021/01/modifying-the-default-configuration-of-linux-practical-operation/</link>
      <pubDate>Sun, 03 Jan 2021 00:10:38 +0800</pubDate>
      
      <guid>/posts/2021/01/modifying-the-default-configuration-of-linux-practical-operation/</guid>
      <description>修改vim中tab长度 设置vim中tab长度
1 2 3  vim /etc/vimrc set tabstop=4   修改vim自动缩进长度 1 2 3  vim /etc/vimrc set shiftwidth=4   禁用烦人的蜂鸣声  禁用bash蜂鸣声  1 2 3  vim /etc/inputrc set bell-style none   禁用vim蜂鸣声  1 2 3  vim /etc/vimrc set noeb vb t_vb=   (vb即visual bell用屏幕的闪烁代替响铃 t_vb就是闪烁设置为空，即不表现出闪烁)</description>
    </item>
    
    <item>
      <title>图的着色问题汇总</title>
      <link>/posts/2020/12/summary-of-coloring-problems-of-graphs/</link>
      <pubDate>Sat, 05 Dec 2020 12:34:05 +0800</pubDate>
      
      <guid>/posts/2020/12/summary-of-coloring-problems-of-graphs/</guid>
      <description>二分图问题 能否只用2种颜色对一个图上色，并且使得共边顶点不同色？
代码解决：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  vector&amp;lt;int&amp;gt; G[MAX_V]; int vertexes; int edges; int color[MAX_V]; //二分图，颜色为1或-1 bool dfs(int v, int c) { color[v] = c; for (int i = 0; i &amp;lt; G[v].size(); i++) { if (color[G[v][i]] == c) return false; if (color[G[v][i]] == 0 &amp;amp;&amp;amp; !dfs(G[v][i], -c)) return false; } return true; } void solve() { for (int i = 0; i &amp;lt; vertexes; i++) { if (color[i] == 0) { if (!</description>
    </item>
    
    <item>
      <title>求解有向图和无向图中是否存在环的方法</title>
      <link>/posts/2020/12/a-method-to-solve-whether-there-are-rings-in-directed-graphs-and-undirected-graphs/</link>
      <pubDate>Wed, 02 Dec 2020 23:50:44 +0800</pubDate>
      
      <guid>/posts/2020/12/a-method-to-solve-whether-there-are-rings-in-directed-graphs-and-undirected-graphs/</guid>
      <description>求解无向图中是否存在环 无向图中是否存在环，可以通过DFS来实现。
由于他是无向图，所以每次开始一次新的递归即进入一个新的连通子图，在该次dfs中可以通过判断新纳入的结点是否与所在连通子图中其他已经访问过的结点存在边，如果存在则证明存在环。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  int mat[maxn][maxn], vis[maxn]; int dfs(int v) { vis[v] = 1; for (int i = 0; i &amp;lt; num; i++) if (mat[v][i]) { if (vis[i] || dfs(i)) return 1; // 该连通子图新纳入的结点与原连通子图中的某一结点有边，即产生了环  } return 0; } memset(vis, 0, sizeof(vis)); int flag = 0; // 无环标志 for (int j = 0; j &amp;lt; num; j++) { if (!</description>
    </item>
    
    <item>
      <title>二次元随想</title>
      <link>/posts/2020/11/two-dimensional-capriccio/</link>
      <pubDate>Sat, 28 Nov 2020 18:24:12 +0800</pubDate>
      
      <guid>/posts/2020/11/two-dimensional-capriccio/</guid>
      <description>之前看完冰菓之后，内心有一丝莫名的伤感。最近终于也把春物小说读完了，同样的感觉又涌上心头，这是一种难以言说的情愫。
也许是对一段故事谢幕的不舍。欣赏一部优秀的作品，走进另一个世界，见证一段故事。在故事尾声，我总希望剧情能不断延长下去。可就像一段青春时光，一段故事总要落幕。结束了的就只能成为回忆&amp;hellip;&amp;hellip;虚拟世界里的东西，往往是现实中难以企及的。
也许是对二次元世界的那种向往。 二次元世界有着独特的美感，每一个画面都扣人心弦，那种干净的，美好的画面，都是现实中难以遇见的。尤其是京阿尼的冰菓，每一帧画面都是精品。所以在经历了一段时间的美感洗礼之后又回到现实，我也许因此莫名的迷惘，失落吧。
也许是对故事中那种青春的向往。 想体验那种玫瑰色的青春，体验青春中真挚的，纯真的感情。随着时间流逝，我也许已经不再有机会。
不管如何，二次元，再扩展到所有的文学艺术作品，与现实都是有一定的距离的。但就算是如此，我们一样可以在现实中找寻生活的美与希望。尽管我们难以企及故事中的那般美好，生活有时总是那么不如意，但是我觉得只要自然地生活下去，用心生活下去，总能在不经意间体会到现实生活中的，不一样的美，与快乐。
另外，阅览一个故事，也可以算是经历了一段故事吧，尽管不是故事的主人公，但也已经在自己的人生中体验到了另一种生活的感觉，尽管那种体验不那么真实，但它也给你带来了一笔无比珍贵的宝物。
每个人都会过完自己独特的一生吧，把握住当下，去做自己喜欢做的事，对，这一点就是我觉得的，很重要的东西。不要浮躁，不要回到曾经的那种焦虑与迷惘。切实地理解自己，品味生活，偶尔让身心慢下来，不要逼自己去做太多不必要的事情。“不必要的事情不管，必要的事情尽快完成”，这种节能思想我觉得还是很值得借鉴的。毕竟我觉得懂得偷闲的人，也许都过的更快乐一点吧。</description>
    </item>
    
    <item>
      <title>equals方法和==运算符的作用区别</title>
      <link>/posts/2020/11/the-difference-between-the-equals-method-and-the-operator/</link>
      <pubDate>Wed, 25 Nov 2020 00:21:05 +0800</pubDate>
      
      <guid>/posts/2020/11/the-difference-between-the-equals-method-and-the-operator/</guid>
      <description>equals方法与&amp;quot;==&amp;ldquo;的比较与分析 首先提出一个重要的点:
  == 比较时进行地址的比较
  equals 比较时进行值的比较
  1 2 3 4 5 6 7 8 9  String a = &amp;#34;123&amp;#34;; String b = &amp;#34;123&amp;#34;; System.out.println(a.equals(b)); // true System.out.println(a == b); // true  String a1 = new String(&amp;#34;123&amp;#34;); String b1 = new String(&amp;#34;123&amp;#34;); System.out.println(a1.equals(b1)); // true System.out.println(a1 == b1); // false   好像没问题。
然而阅读源码Object类，可以发现对象中默认equals方法进行的是地址的比较
1 2 3  public boolean equals(Object obj) { return (this == obj); }   再阅读源码String类，可以发现String类中重写了equals方法，覆盖掉了Object的equals方法，所以String的equals是值比较！</description>
    </item>
    
    <item>
      <title>Cmd重要且实用的一些命令</title>
      <link>/posts/2020/11/cmd-some-important-and-practical-commands/</link>
      <pubDate>Fri, 20 Nov 2020 18:17:33 +0800</pubDate>
      
      <guid>/posts/2020/11/cmd-some-important-and-practical-commands/</guid>
      <description>写入文件  写入hello字符串（同时新建了a.txt）  1  echo hello &amp;gt; a.txt    追加写入hello字符串  1  echo hello &amp;gt;&amp;gt; a.txt    将a.txt内容追加写入b.txt  1  type a.txt &amp;gt;&amp;gt; b.txt   新建文件  新建空文件a.txt  1  type null &amp;gt; a.txt   换行（分号换行输出） 1  echo hello; echo peter   关于程序编译 test.cpp: 一个含cin输入的程序
编译cpp
1  g++ test.cpp -o test   以1.in作为标准输入，2.out作为标准输出执行test
1  test &amp;lt; 1.</description>
    </item>
    
    <item>
      <title>矩阵快速幂的介绍及其应用</title>
      <link>/posts/2020/11/introduction-and-application-of-matrix-fast-power/</link>
      <pubDate>Wed, 18 Nov 2020 23:47:15 +0800</pubDate>
      
      <guid>/posts/2020/11/introduction-and-application-of-matrix-fast-power/</guid>
      <description>矩阵快速幂介绍 题目描述
给定n×n的矩阵A，求 A^k。
输入格式
第一行两个整数 n,k 接下来n行，每行n个整数，第i行的第j个数表示Aij。
输出格式
输出 A^k
共n行，每行n个数，第i行第j个数表示Aij, 每个元素对 10^9+7取模。
1 &amp;lt;= n &amp;lt;= 100
0 &amp;lt;= k &amp;lt;= 10 ^ 12
|Aij| &amp;lt;= 1000
分析：
本质上就是快速幂运算，只是底数变成了一个矩阵。
快速幂运算板子： 1 2 3 4 5 6 7 8 9 10  typedef long long ll; ll mod_pow(ll x, ll n, ll mod){ ll res = 1; while(n &amp;gt; 0){ if(n &amp;amp; 1 == 1) res = res * x % mod; // 如果指数是奇数则乘上底数 	x = x * x % mod; // 底数平方 	n &amp;gt;&amp;gt;= 1; // 指数除二 	}	return res; }   由此易得：</description>
    </item>
    
    <item>
      <title>SSH免密且免IP登录远程主机的方法以及遇到的一些问题</title>
      <link>/posts/2020/11/ssh-password-free-and-ip-free-login-methods-to-remote-hosts-and-some-problems-encountered/</link>
      <pubDate>Tue, 17 Nov 2020 17:56:03 +0800</pubDate>
      
      <guid>/posts/2020/11/ssh-password-free-and-ip-free-login-methods-to-remote-hosts-and-some-problems-encountered/</guid>
      <description>问题的提出： 我们可以通过指令：
1  ssh 用户名@IP   登录远程主机，但是每次都要输入ip和密码，有点麻烦，为了节省时间，我们需要寻求提高效率的办法！
通过了解，我们可以通过RSA，即非对称式的加密方法实现免密操作，而免IP只需要在config文件中进行配置即可。
实现免ip登录：   新建config文件
若window下操作，则在.ssh目录中新建一个名为config的文件，而linux下直接编辑ssh_config文件。
  编辑代替名以及IP，端口号，用户。
  1 2 3 4  Host 输入代替名 HostName 输入IP Port 输入端口号 User 输入用户   这样，即可通过
1  ssh 代替名   进行登录咯！
接着我们实现免密登录：  在本地生成密钥：  1  ssh-keygen   并选择生成在.ssh目录下即可，获得一把公钥和私钥。
将名字带.pub的就是公钥了。
 将公钥发给远程主机  通过命令
1  ssh-copy-id -i .ssh/公钥 用户名@IP   即可发送给远程主机。
在window10中可能出现以下错误：
1  ssh-copy-id : 无法将“ssh-copy-id”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。   则可先于命令行中运行以下代码：</description>
    </item>
    
    <item>
      <title>最短路问题汇总</title>
      <link>/posts/2020/11/summary-of-shortest-path-problems/</link>
      <pubDate>Tue, 17 Nov 2020 17:55:32 +0800</pubDate>
      
      <guid>/posts/2020/11/summary-of-shortest-path-problems/</guid>
      <description>注意，这里为了方便描述算法，所以都用了最易理解的邻接矩阵来写，比赛中为了追求效率，一般将邻接矩阵改为链式前向星或者邻接表。
迪杰斯特拉算法 O(V^2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  const int MAXN = 100; const int INF = 0x3f3f3f3f; // 有向无环图 DAG int V, E; // 顶点数和边数 int graph[MAXN][MAXN]; // DAG邻接矩阵，初始值为INF，不可达为INF，否则为cost值 int d[MAXN]; // 从某点s出发到其它任意结点的最短路径长度，初始值为INF int visited[MAXN]; // 某点是否访问过，访问过则为1否则为0  // 初始化图 void init() { memset(graph, 0x3f, sizeof(graph)); cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E; int from, to, cost; for (int i = 0 ; i &amp;lt; E; i++) { cin &amp;gt;&amp;gt; from &amp;gt;&amp;gt; to &amp;gt;&amp;gt; cost; graph[from][to] = cost; } } // 迪杰斯特拉算法求解最短路，针对点展开 void Dijkstra(int s) { memset(d, 0x3f, sizeof(d)); memset(visited, 0, sizeof(visited)); visited[s] = 1; for(int i = 0; i &amp;lt; V; i++) d[i] = graph[s][i]; d[s] = 0; int k, min_cost; // 无负边时最多更新n-1(其他结点数)次 	for(int i = 0; i &amp;lt; V - 1; i++){ min_cost = INF; // 寻找最未被访问的且权值最小的路径，需要优化的地方 	for(int j = 0; j &amp;lt; V; j++){ if(!</description>
    </item>
    
    <item>
      <title>关于辗转相除法和扩展欧几里得算法</title>
      <link>/posts/2020/07/on-rolling-division-and-extended-euclidean-algorithm/</link>
      <pubDate>Tue, 21 Jul 2020 20:48:53 +0800</pubDate>
      
      <guid>/posts/2020/07/on-rolling-division-and-extended-euclidean-algorithm/</guid>
      <description>gcd辗转相除法求最大公约数 思路：反复交换取余，直到小的数为0。
1 2 3 4  int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b); }   exgcd扩展欧几里得算法 先介绍贝祖定理：
若a,b为整数，则一定存在整数x,y，使得$ax + by = gcd(a,b)$。
即若$ax + by = m$有解，则m一定为gcd(a,b)的若干倍。
下面是一道题：
有a, -a, b, -b四个整数，各用几次可以使得$ax + by = 1$?
由上述思想则可知gcd(a,b)等于1，可编写一个返回值为gcd(a,b)同时递归计算x和y的函数。
关于求出x和y推导过程：
由$ax + by = gcd(a,b)$ (1)
通过辗转相除法的思想得：$bx_1 + (a \mod b) y_1 = gcd(a,b)$
由$a \mod b = a - (a \div b) \times b$带入得:</description>
    </item>
    
    <item>
      <title>有关素数的一些算法</title>
      <link>/posts/2020/07/some-algorithms-about-prime-numbers/</link>
      <pubDate>Tue, 21 Jul 2020 20:43:04 +0800</pubDate>
      
      <guid>/posts/2020/07/some-algorithms-about-prime-numbers/</guid>
      <description>埃氏筛法 问1000000000000以内有多少个素数？
运用朴素算法必TLE，这时考虑埃氏筛法。
算法思路：
 建立is_prime[]数组，初始化为true； 从2开始筛取，(注意从2开始很重要，因为2为素数，否则需要改变相应后续操作)，若为true，则继续判断是否为素数，若为素数，则将所有该素数的倍数置为false。  相应代码：
1 2 3 4 5 6 7 8 9 10 11 12 13  bool is_prime[MAXN]; //返回n以内的素数个数 int sieve(int n) { int c = 0; for (int i = 2; i &amp;lt;= n; ++i) is_prime[i] = true; for (int i = 2; i &amp;lt;= n; ++i) if (is_prime[i]) { c++; for (int j = 2 * i; j &amp;lt;= n; j += i) is_prime[j] = false; } return c; }   区间筛法 问[21479862, 21499877)之间有多少个素数？</description>
    </item>
    
    <item>
      <title>Python自动爬取花瓣网任意面板中所有图片</title>
      <link>/posts/2020/02/python-automatically-crawls-all-pictures-in-any-panel-of-petal-net/</link>
      <pubDate>Thu, 13 Feb 2020 00:14:23 +0800</pubDate>
      
      <guid>/posts/2020/02/python-automatically-crawls-all-pictures-in-any-panel-of-petal-net/</guid>
      <description>注：该项目只适用于旧版花瓣，但其中的思路值得领会。对于新版花瓣编写的代码，逻辑差别不大。
需要安装的库  urllib easygui selenium webdriver_manager  获取过程  进入面板内 复制当前面板url 启动该脚本按提示进行即可  代码编写流程 分析pin图特点 查看面板源码，可以在对应的script中找到面板中图片的json数据。
在app.page[&amp;ldquo;board&amp;rdquo;]下可以找到&amp;quot;pins&amp;quot;:[{&amp;hellip;}]，主要图片ID(pin)位于这里面。
获取到图片的ID(pin)之后可以对应访问点击图片后进入的地址http://huaban.com/pins/pinId/，并获取页面源码：
显然可见主要图片的源码特征，书写对应正则表达式可以获取图片真实地址。
分析滚动特点 通过滚动页面我们可以发现加载规律：
原来的图片对应的代码：
经过滚动，原来的代码逐渐被一些新的代码取代：
而不难发现他们都有对应的data-id!而data-id就是图片地址中对应的pin。
所以我们可以通过webdriver滚动加载页面，每滚动一次就进行一次data-id的读取，并利用集合进行去重即可。
具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  # 花瓣用户任意面板图片爬取 import urllib.</description>
    </item>
    
    <item>
      <title>Matlab基本用法整理</title>
      <link>/posts/2020/02/basic-usage-sorting-of-matlab/</link>
      <pubDate>Thu, 06 Feb 2020 20:41:12 +0800</pubDate>
      
      <guid>/posts/2020/02/basic-usage-sorting-of-matlab/</guid>
      <description>基本语法方面 提取矩阵某行或某列 1  A(:, [2 3]) 返回第2和第3列   获取随机数 1  randi(100); % 1 到 100 之间的随机整数   初始化数组 1  zeros(1, 30); % 1行30列的全0数组   控制语句 1 2 3 4 5 6 7 8 9 10  for i = 0 : 100 for j = 1 : 10 if (...)  ... else ... end end ... end   格式化输出 1  fprintf(&amp;#34;若选手选择改变，则成功次数为：%d, 成功率为：%f\n&amp;#34;, count, count / SUM);   初等数学方面 求解方程组 注：solve已经改版，不可传入字符串</description>
    </item>
    
  </channel>
</rss>
